---
title: Probability
author: David Kane and Tanay Janmanchi
tutorial:
  id: probability
output:
  learnr::tutorial:
    progressive: yes
    'allow_skip:': yes
runtime: shiny_prerendered
description: 'Chapter 2 Tutorial: Probability'
---

```{r setup, include = FALSE}
library(learnr)
library(tutorial.helpers)
library(tidyverse)
library(primer.data)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 

shoesize_p <- tibble(Wshoes = rnorm(n = 100000, mean = 8, sd = 1.5),
       Mshoes = rnorm(n = 100000, mean = 10.5, sd = 1.5)) |> 
  pivot_longer(cols = everything(), 
               names_to = "distribution", 
               values_to = "value") |>  
   ggplot(aes(x = value, fill = distribution)) +
    geom_histogram(aes(y = after_stat(count/sum(count))),
                   alpha = 0.5, 
                   bins = 100, 
                   position = "identity") +
    labs(title = "Normal Distributions of shoe sizes",
         x = "Value",
         y = "Probability")

emp_p <- 
  tibble(results = sample(c(0, 1), 100, replace = TRUE)) |> 
  ggplot(aes(x = results)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 0.5, 
                   color = "white") +
    labs(title = "Empirical Probability Distribution",
         subtitle = "Flipping one coin a hundred times",
         x = "Outcome\nResult of Coin Flip",
         y = "Probability") +
    scale_x_continuous(breaks = c(0, 1), 
                       labels = c("Heads", "Tails")) +
    scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
    theme_classic()

set.seed(1)
emp_dist_dice <- tibble(ID = 1:100) |> 
  mutate(die_1 = map_dbl(ID, ~ sample(c(1:6), size = 1))) |> 
  mutate(die_2 = map_dbl(ID, ~ sample(c(1:6), size = 1))) |> 
  mutate(sum = die_1 + die_2) |> 
  ggplot(aes(x = sum)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 1, 
                   color = "white") +
    labs(title = "Empirical Probability Distribution",
         subtitle = "Sum from rolling two dice, replicated one hundred times",
         x = "Outcome\nSum of Two Die",
         y = "Probability") +
    scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) +
    scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
    theme_classic()

emp_mpg <- mpg |>
  filter(drv == "f", cty >= 16) |>
  select(displ)|>
  drop_na() |>
  ggplot(aes(x = displ)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                 binwidth = 1, 
                 color = "white")+
  labs(title = "Empirical Probability Distribution",
       subtitle = "Engine Displacement for front-wheel drive cars from mpg",
       x = "Engine Displacement",
       y = "Probability",caption = "Source:mpg") +
  scale_y_continuous(labels =
                      scales::percent_format(accuracy = 1)) +
  theme_classic()

jd_disease <- tibble(ID = 1:10000, 
                     have_disease = rep(c(TRUE, FALSE), 
                                    5000)) |> 
  mutate(positive_test = if_else(have_disease,
          map_int(have_disease, ~ rbinom(n = 1, size = 1, p = 0.99)),
          map_int(have_disease, ~ rbinom(n = 1, size = 1, p = 0.5))))

joint_p <- tibble(in_bag = rep(c(0, 1, 2), 1000)) |>
  mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1, 
                                              size = 3, 
                                              p = ./2))) |>
  ggplot(aes(x = in_sample, y = in_bag)) +
    geom_jitter(alpha = 0.5) +
    labs(title = "Black and White Marbles",
         subtitle = "More white marbles in bag mean more white marbles selected",
         x = "White Marbles Selected",
         y = "White Marbles in the Bag") +
    scale_y_continuous(breaks = c(0, 1, 2)) +
  theme_classic()

emp_p <- tibble(p = rep(seq(0, 1, 0.1), 1000)) |>
  mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) |>
  ggplot(aes(y = p, x = heads)) +
    geom_jitter(alpha = 0.1) +
    labs(title = "Empirical Distribution of Number of Heads",
         subtitle = expression(paste("Based on simulations with various values of ", rho[h])),
         x = "Number of Heads out of 20 Tosses",
         y = expression(rho[h])) +
  scale_y_continuous(breaks = seq(0, 1, 0.1)) +
  theme_classic()

```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

<!-- DK: Change mayor example to be Parisians overhearing Arabic. Need question to be close to the data. -->

<!-- DK: Build up questions to Preceptor Table slowly. First, causal or predictive? First, what are the units. Second, what is the outcome? Third, what are the covariates? Fourth, only if causal, what are the treatments. -->

<!-- MAKE THIS MATCH THE NEW VERSION OF THE PRIMER. The stuff we have is good, but there is nothing about the Cardinal Virtues. -->

<!-- Tricks to keep in mind when doing simulations in R: First, organize everything in a tibble. This makes it easy to see what is going on. Often, we will first make sure that the code is working with a small tibble with just a few rows and selected values for the key variables. Then, when that looks good, run it for real with x = 1:100 or whatever. -->

<!-- Second, build the tibble column-by-column. We will often start with an ID column whose only purpose is to set up the size of the tibble. Then, we add new columns with mutate(). Often, we add one column and then use that column as input to a map function which adds another column and then use that column to do something else. Read the examples in Chapter 6 closely. -->

<!-- Third, recall that map() returns a list, which allows you to create a list-column. This is very handy. Let's say you want to get the sum of 6 rolls from a dice. Instead of doing a roll in each row and then summing the rows --- which can work but which can also be a bother --- use something like `mutate(six_rolls = map(ID, ~  roll_die(n = 6))` to get a list of the 6 rolls. You can then manipulate six rolls, which is a list-column, in subsequent steps. -->


## Introduction
### 

This tutorial covers [Chapter 2: Probability](https://ppbds.github.io/primer/probability.html) of [*Preceptorâ€™s Primer for Bayesian Data Science: Using the Cardinal Virtues for Inference*](https://ppbds.github.io/primer/) by [David Kane](https://davidkane.info/). 

This tutorial will review 5 key lessons:
  1. Learn about `list()` ,`map()`, `map_*()`, and `tibble()` functions.
  2. Practice using `tibble()`, `mutate()`,`map_*()`, `rep()` and `sample()` to generate data.
  3. Learn about different types of distribution.
  4. Create distributions using tools above and from earlier chapters.
  5. Start thinking about the meaning of each distribution by looking at each graph.

## Distributions
### 

Let's create this normal distribution by the end of this section.

```{r distributions-0}
shoesize_p <- tibble(Wshoes = rnorm(n = 100000, mean = 8, sd = 1.5),
       Mshoes = rnorm(n = 100000, mean = 10.5, sd = 1.5)) |> 
  pivot_longer(cols = everything(), 
               names_to = "distribution", 
               values_to = "value") |>  
   ggplot(aes(x = value, fill = distribution)) +
    geom_histogram(aes(y = after_stat(count/sum(count))),
                   alpha = 0.5, 
                   bins = 100, 
                   position = "identity") +
    labs(title = "Normal Distributions of shoe sizes",
         x = "Value",
         y = "Probability")

shoesize_p
```

### Exercise 1

Use `tibble()` to create a tibble with one variable: `numbers`, and set `numbers` equal to the consecutive integers from 1 to 101 inclusive using `:`.

```{r distributions-1, exercise = TRUE}

```

```{r distributions-1-hint-1, eval = FALSE}
tibble(... = 1:101)
```

```{r distributions-1-test, include = FALSE}
tibble(numbers = 1:101)
```

### 

Note that the vector of `numbers` is integers, if you try putting `c()` around the two numbers, and
replace `:` with `,`, the two numbers become `double` instead.

### Exercise 2

Pipe the results to `summarize()`, create a new column name `avg` which is equal to the `mean()` of `numbers`.

```{r distributions-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r distributions-2-hint-1, eval = FALSE}
...|>
  summarize(avg = mean(...))
```

```{r distributions-2-test, include = FALSE}
tibble(numbers = 1:101) |> 
  summarize(avg = mean(numbers))
```

### 

`summarize()` does not keep any of the variables in the input tibble, unless the `.by` argument is used.


### Exercise 3

Within the `summarize()`, add a new argument, `middle`, and set it equal to the `median()` of `numbers`. Remember to use commas to separate your arguments.

```{r distributions-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r distributions-3-hint-1, eval = FALSE}
... |> 
  summarize(...,
            middle = median(...))
```

```{r distributions-3-test, include = FALSE}
tibble(numbers = 1:101) |> 
  summarize(avg = mean(numbers),
            middle = median(numbers))
```

### 

Both `mean()` and `median()` have the `na.rm` value set to its default `FALSE`, the `na.rm` means the function does not consider NA value in the tibble.

### Exercise 4

Within the `summarize()`, add a new argument, `stan_dev`, set it equal to the standard deviation of `numbers` using `sd()`.



```{r distributions-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r distributions-4-hint-1, eval = FALSE}
... |> 
  summarize(...,
            ...,
            stan_dev = sd(...))
```

```{r distributions-4-test, include = FALSE}
tibble(numbers = 1:101) |> 
  summarize(avg = mean(numbers),
            middle = median(numbers),
            stan_dev = sd(numbers))
```

### 

Note that the `x` value inside `mean()` ,`median()` and `sd()` has to be a numeric vector, not a factor or logical. 

Recall standard deviation is measuring how spread out our numbers are.

### Exercise 5

Within the `summarize()`, add a new argument, `med_dev` and set it equal to `mad(numbers)`. 

```{r distributions-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r distributions-5-hint-1, eval = FALSE}
... |> 
  summarize(...,
            ...,
            ...,
            med_dev = mad(...))
```

```{r distributions-5-test, include = FALSE}
tibble(numbers = 1:101) |> 
  summarize(avg = mean(numbers),
            middle = median(numbers),
            stan_dev = sd(numbers),
            med_dev = mad(numbers))
```

### 

`mad` stands for median absolute deviation, essentially it's how spread out the values are around the median, note that the number should be different in this case. `sd()` is looking for the square of difference, yet `mad()` is looking at the absolute difference.

### Exercise 6

Last but not least, within `summarize()`, set `qtile` to `quantile()`. Within it, set the first argument to `numbers`, and the second to `prob` which is equal to `c(0, 0.5, 1)`.

```{r distributions-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r distributions-6-hint-1, eval = FALSE}
... |> 
  summarize(...,
            ...,
            ...,
            ..., 
            qtile = quantile(..., prob = c(..., ..., ...)))

```

```{r distributions-6-test, include = FALSE}
tibble(numbers = 1:101) |> 
  summarize(avg = mean(numbers),
            middle = median(numbers),
            stan_dev = sd(numbers),
            med_dev = mad(numbers), 
            qtile = quantile(numbers, prob = c(0, 0.5, 1)))

```

### 

This will create another two rows, because quantile has three values in it's column, yet if we want to keep it in one row, we can add `list()` around `quantile()`, so that we create a list-column for column quantile and keep everything else in 1 row.


### Exercise 7

Create a new tibble. Make the first column name as `ID`, and set it equal to all the consecutive integers from 1 to 100. Then make a second column named `scores`, and set it equal to a vector `c()`. Inside the vector use `rep()` to make value `1350` occur 20 times, value `1380` occur 30 times, `1440` occur 40 times, and `1520` occur 10 times.



```{r distributions-7, exercise = TRUE}

```

```{r distributions-7-hint-1, eval = FALSE}
tibble(... = 1:100 , scores = c(rep(..., 20),
                                rep(1380, ...),
                                rep(1440, ...),
                                rep(1520, ...)))
```

```{r distributions-7-test, include = FALSE}
tibble(ID = 1:100 , scores = c(rep(1350, 20),
                               rep(1380, 30),
                               rep(1440, 40),
                               rep(1520, 10)))
```

### 

We can use `c()` to combine the `rep()` of numbers into vectors, and within `tibble()` or `mutate()` we can turn this vector into a column.

### Exercise 8

Now let's say you are an admissions officer, and here's the score, now you want to look at the percentile of that score. After the previous code, pipe the `summarize()` function to make a new column `percentile`, and set equal to `quantile()`, first argument is `scores`, the second is `prob`, and set it equal to `c(.35, .50, .75)`.

```{r distributions-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r distributions-8-hint-1, eval = FALSE}
... |>
      summarize(percentile = quantile(scores, prob = c(..., ..., ...)))
```

```{r distributions-8-test, include = FALSE}
tibble(ID = 1:100 , 
       scores = c(rep(1350, 20),
                               rep(1380, 30),
                               rep(1440, 40),
                               rep(1520, 10))) |> 
                               summarize(percentile = quantile(scores, prob = c(.35, .50, .75)))
```

### 

The function `quantile()` produces sample quantiles corresponding to the given probabilities. The smallest observation corresponds to a probability of 0 and the largest to a probability of 1.

### Exercise 9

Now let's say instead of looking at the percentile you want to randomly pick 10 people from 1350 to 1520 score range to admit. Within `summarize()`, replace `percentile` with `admit`, and set it equal to `sample()`. Within `sample()`, set the first argument to `scores`, second to `size` equal to `10`, and third to `replace` which you set to `FALSE`.

```{r distributions-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r distributions-9-hint-1, eval = FALSE}
... |>
      summarize(..., 
                percentile = quantile(scores, prob = c(..., ... = ..., ... = ...)))
```

```{r distributions-9-test, include = FALSE}
tibble(ID = 1:100 , 
       scores = c(rep(1350, 20),
                               rep(1380, 30),
                               rep(1440, 40),
                               rep(1520, 10))) |> 
                               summarize(admit = sample(scores, size = 10, replace = FALSE))
```

### 

Within `sample()`, the first argument represents the data source, `size` means the number of values we are picking, and `replace` means whether we pick the same value twice.

### Exercise 10

Let's now use `runif()` to draw from a uniform distribution. Within `runif()`, set `n` to 5 (the number of draws), `min` to 5, and `max` to 8. 

```{r distributions-10, exercise = TRUE}

```

```{r distributions-10-hint-1, eval = FALSE}
runif(n = ..., 
      min = ..., 
      max =...)
```

```{r distributions-10-test, include = FALSE}
runif(n = 5, min = 5, max = 8)
```

### 

The [runif](https://www.geeksforgeeks.org/create-random-deviates-of-uniform-distribution-in-r-programming-runif-function/) function creates a random uniform distribution between your chosen minimum and maximum values.

### Exercise 11

Run `tibble()`, set the argument `heads` equal to `rbinom()`, with the first argument equal to `1000`, second argument `size` equal to `1`, and the third argument `prob` equal to `0.5`.

```{r distributions-11, exercise = TRUE}

```

```{r distributions-11-hint-1, eval = FALSE}
tibble(heads = rbinom(n = ..., size = ..., prob = ...))
```

```{r distributions-11-test, include = FALSE}
tibble(heads = rbinom(n = 1000, size = 1, prob = 0.5))
```

### 

`rbinom()` is used for the scenario where there is only two possible outcome also known as Boolean data type, the coin toss in this case is an example of Boolean data. Within `rbinom()` the value `n` means how many value is draw, `size` is how many value draws each time, and `prob` is the probability of the outcome.

### Exercise 12

We can give a quick look at what the graph looks like, pipe the `tibble()` from the previous code to `ggplot()`, within `ggplot()`, use `aes()` and set `x =  heads`, then add the layer `geom_bar()`. Set `binwidth` to `0.5`.

```{r distributions-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r distributions-12-hint-1, eval = FALSE}
... |>
  ggplot(aes(...)) +
  geom_histogram(binwidth = ...)
```

```{r distributions-12-test, include = FALSE}
tibble(heads = rbinom(n = 1000, size = 1, prob = 0.5)) |>
  ggplot(aes(x = heads)) +
  geom_histogram(binwidth = 0.5)
```

### 

In this case `geom_col()` won't work because it need an y aesthetic, `geom_bar()` is better than `geom_histogram()` in this scenario because `geom_bar()` automatically fixes the `binwidth` for you, while `geom_histogram()` requires you to set the `binwidth` yourself. 

### Exercise 13

Start a pipe with `tibble()`, create an value `Wshoes`, set it equal to `rnorm()`, set the first argument to `100000`, the second argument `mean` equal to `8`, and third argument `sd` to `1.5`. Create another value `Mshoes` in `tibble()`, set it equal to `rnorm()`, set the first argument to `100000`, the second argument `mean` equal to `10.5`, and third argument `sd` to `1.5`.

```{r distributions-13, exercise = TRUE}

```

```{r distributions-13-hint-1, eval = FALSE}
tibble(Wshoes = rnorm(..., mean = ..., sd = ...),
       Mshoes = rnorm(..., mean = ..., sd = ...))
```

```{r distributions-13-hint-2, eval = FALSE}
tibble(Wshoes = rnorm(100000, mean = 8, sd = 1.5),
       Mshoes = rnorm(100000, mean = 10.5, sd = 1.5))
```

### 

Within `rnorm()` the first argument means how many times we are drawing, the second argument `mean` is the mean of the distribution, and the third argument `sd` is the standard deviation for the distribution. Normal distribution is mostly used for things that are very common for most people, but uncommon as they get far away from their average value. Examples could be height, blood pressure, IQ value, shoe sizes, etc.

### Exercise 14

Let's prepare to plot our tibble. Continue the pipe with `pivot_longer()`. Set `cols` to `everything()`, `names_to` to "Distribution", and `values_to` to  "draw".

```{r distributions-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r distributions-14-hint-1, eval = FALSE}
... |> 
    pivot_longer(cols = ...,
                 names_to = ...,
                 values_to = ...)
```

```{r distributions-14-test, include = FALSE}
tibble(Wshoes = rnorm(100000, mean = 8, sd = 1.5),
       Mshoes = rnorm(100000, mean = 10.5, sd = 1.5)) |> 
          pivot_longer(cols = everything(),
                 names_to = "Distribution",
                 values_to = "draw")
```

### 

`pivot_longer()` "lengthens" data, increasing the number of rows and decreasing the number of columns. The inverse transformation is `pivot_wider()`

### Exercise 15

Continue your pipe with `ggplot()` to map `x` to `draw` and `fill` to `Distribution`. Add the layer `geom_histogram()`. Within `geom_histogram()`, use `aes()`, inside `aes()`, set `y` equals to `after_stat()` with `count/sum(count)` as the argument.

```{r distributions-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r distributions-15-hint-1, eval = FALSE}
...|>  
   ggplot(aes(x = ..., fill = ...)) +
    geom_histogram(aes(y = after_stat(...)))
```

```{r distributions-15-test, include = FALSE}
tibble(Wshoes = rnorm(100000, mean = 8, sd = 1.5),
       Mshoes = rnorm(100000, mean = 10.5, sd = 1.5)) |> 
          pivot_longer(cols = everything(),
                 names_to = "Distribution",
                 values_to = "draw") |>
          ggplot(aes(x = draw, fill = Distribution)) +
                geom_histogram(aes(y = after_stat(count/sum(count))))
```

### Exercise 16

Using the previous code, set `alpha` to `0.5`, `bins` to `100`, and `position` to `"identity"` within `geom_histogram()`.

```{r distributions-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r distributions-16-hint-1, eval = FALSE}
... |> 
   geom_histogram(...,
                  alpha =  ..., 
                  bins =  ..., 
                  position = ...)
```

```{r distributions-16-test, include = FALSE}
tibble(Wshoes = rnorm(100000, mean = 8, sd = 1.5),
       Mshoes = rnorm(100000, mean = 10.5, sd = 1.5)) |> 
          pivot_longer(cols = everything(),
                 names_to = "Distribution",
                 values_to = "draw") |>
          ggplot(aes(x = draw, fill = Distribution)) +
                geom_histogram(aes(y = after_stat(count/sum(count))),
                               alpha = 0.5,
                               bins = 100,
                               position = "identity")
```

### Exercise 17

Finally, use `labs()` to title your graph "Normal Distributions of shoe sizes". Also label your x-axis "Value" and y-axis "Probability".
```{r distributions-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r distributions-17-test, include = FALSE}
tibble(Wshoes = rnorm(n = 100000, mean = 8, sd = 1.5),
       Mshoes = rnorm(n = 100000, mean = 10.5, sd = 1.5)) |> 
  pivot_longer(cols = everything(), 
               names_to = "distribution", 
               values_to = "value") |>  
   ggplot(aes(x = value, fill = distribution)) +
    geom_histogram(aes(y = after_stat(count/sum(count))),
                   alpha = 0.5, 
                   bins = 100, 
                   position = "identity") +
    labs(title = "Normal Distributions of shoe sizes",
         x = "Value",
         y = "Probability")
```

Reminder: This is what your plot should look like. 

```{r}
shoesize_p
```

## PD for flipping a coin 
### 

Let's create the following *empirical distribution* of flipping a fair coin. Recall, that empirical distribution is based on data therefore we need to simulate our data, that is "flipping the coin" by ourselves.

```{r}
emp_p <- 
  tibble(results = sample(c(0, 1), 100, replace = TRUE)) |> 
  ggplot(aes(x = results)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 0.5, 
                   color = "white") +
    labs(title = "Empirical Probability Distribution",
         subtitle = "Flipping one coin a hundred times",
         x = "Outcome\nResult of Coin Flip",
         y = "Probability") +
    scale_x_continuous(breaks = c(0, 1), 
                       labels = c("Heads", "Tails")) +
    scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
    theme_classic()

emp_p
```

### Exercise 1

Let's simulate flipping a coin, use `sample()`, within `sample()`, set the first argument to `0` and `1`, where `0` represent tails and `1` represent heads, second argument to repeat 100 times, and third argument set `replace` equal to `TRUE`, so that we can generate different values.

```{r pd-for-flipping-a-coin-1, exercise = TRUE}

```

```{r pd-for-flipping-a-coin-1-hint-1, eval = FALSE}
sample(c(...), ... , replace = ...)
```

```{r pd-for-flipping-a-coin-1-test, include = FALSE}
sample(c(0, 1), 100, replace = TRUE)
```

### 

Essentially we are flipping a coin 100 times on our own on the computer. This is one way we can get access to our *population*, which contains all the data we need.

### Exercise 2

Create a tibble with one variable `results` . Have `results` take on the values of the `sample()` code in the previous exercise.  

```{r pd-for-flipping-a-coin-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-flipping-a-coin-2-hint-1, eval = FALSE}
tibble(... = sample(c(...), ..., ...))
```

```{r pd-for-flipping-a-coin-2-test, include = FALSE}
tibble(results = sample(c(0, 1), 100, replace = TRUE))
```

### 

`sample()` is what we always use in flipping coins, rolling dice, and other simple probability problems, where we can pick a value and repeat it as many times as we want.

### Exercise 3

Pipe your results to `ggplot()`. Map `results` to the x-axis. Also add the layer `geom_histogram()`. 

```{r pd-for-flipping-a-coin-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-flipping-a-coin-3-hint-1, eval = FALSE}
... |> 
  ggplot(mapping = aes(...) + 
  geom_histogram()
```

```{r pd-for-flipping-a-coin-3-test, include = FALSE}
tibble(results = sample(c(0, 1), 100, replace = TRUE)) |> 
  ggplot(aes(x = results)) +
    geom_histogram()
```

### 

The `aes()` within `geom_histogram()` can only be either `x` or `y`, if you want to use both of them, use `geom_col()` or `geom_bar()` instead.

### Exercise 4

Within `geom_histogram()`, inside `aes()`, set the argument `y` to          `after_stat(count/sum(count))`.

```{r pd-for-flipping-a-coin-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-flipping-a-coin-4-hint-1, eval = FALSE}
... +
    geom_histogram(aes(y = after_stat(...) 
```

```{r pd-for-flipping-a-coin-4-test, include = FALSE}
tibble(results = sample(c(0, 1), 100, replace = TRUE)) |> 
  ggplot(aes(x = results)) +
    geom_histogram(aes(y = after_stat(count/sum(count))))
```

### 

There are three stages where you can put aesthetic, `aes()`: first the the normal or default stage that is we set the `aes()` within ggplot, the second stage is after the data is transformed by layers like in geom_histogram(), and the third stage is after the data has been transformed and scaled. Therefore, `after_stat()` is a function we use in the second stage, and it's family function `after_scale()` is used in the third stage.

### Exercise 5

Using the previous code, set `binwidth` to `0.5` and `color` to `"white"` within `geom_histogram()`.

```{r pd-for-flipping-a-coin-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-flipping-a-coin-5-hint-1, eval = FALSE}
... +
  geom_histogram(aes(y = after_stat(count/sum(count))),
                 binwidth = 0.5,
                 color = "white")
```

```{r pd-for-flipping-a-coin-5-test, include = FALSE}
  tibble(results = sample(c(0, 1), 100, replace = TRUE)) |> 
  ggplot(aes(x = results)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 0.5, 
                   color = "white")
```

### 

The color argument within geom_histogram(), determines the color of the bar's framework, it helps us to separate the bars from one another. To change the color of the bar, we would use the argument fill instead of color. 

### Exercise 6

Now use `scale_x_continuous()` so the x-axis has `breaks` at `0` and `1`. Set the `labels` for the breaks as `"Heads"` and `"Tails"`, respectively. 

```{r pd-for-flipping-a-coin-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-flipping-a-coin-6-hint-1, eval = FALSE}
... + 
  scale_x_continuous(breaks = c(..., ...),
                     labels = c(..., ...))
```

```{r pd-for-flipping-a-coin-6-test, include = FALSE}
  tibble(results = sample(c(0, 1), 100, replace = TRUE)) |> 
  ggplot(aes(x = results)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 0.5, 
                   color = "white") +
    scale_x_continuous(breaks = c(0, 1), 
                       labels = c("Heads", "Tails")) 
```

### 

To determine whether to use scale_x_continuous or scale_x_discrete, you need to determine the vector of the variable you want to plot. If your variable is numeric, then use `scale_x_continuous()`, if your variable is factor, then use `scale_x_discrete()`.

### Exercise 7

Now add `scale_y_continuous()` to the previous code to put the y-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to `1`.

```{r pd-for-flipping-a-coin-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-flipping-a-coin-7-hint-1, eval = FALSE}
... + 
  scale_y_continuous(labels = scales::percent_format(...))
```

```{r pd-for-flipping-a-coin-7-test, include = FALSE}
  tibble(results = sample(c(0, 1), 100, replace = TRUE)) |> 
  ggplot(aes(x = results)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 0.5, 
                   color = "white") +
    scale_x_continuous(breaks = c(0, 1), 
                       labels = c("Heads", "Tails")) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1))
```

### 

There is alot more function within scale_y_continuous, includes the limit, expand, guide, position, etc. To learn more about scale_continuous, click [here] (https://ggplot2.tidyverse.org/reference/scale_continuous.html)

### Exercise 8

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels.

```{r pd-for-flipping-a-coin-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

Reminder: Your plot should look similar to the the one below. **Note**: the height of the bars will vary because our `rbinom()` statements generate different proportions every time! If we used the function `set.seed()` then we would be able to replicate our results. Learn more about set.seed [here](https://www.tutorialspoint.com/why-we-should-use-set-seed-in-r).

```{r pd-for-flipping-a-coin-8-test, include = FALSE}
 tibble(results = sample(c(0, 1), 100, replace = TRUE)) |> 
  ggplot(aes(x = results)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 0.5, 
                   color = "white") +
    labs(title = "Empirical Probability Distribution",
         subtitle = "Flipping one coin a hundred times",
         x = "Outcome\nResult of Coin Flip",
         y = "Probability") +
    scale_x_continuous(breaks = c(0, 1), 
                       labels = c("Heads", "Tails")) +
    scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
    theme_classic()

```

```{r}
emp_p
```

### 

Remember the *empirical distribution* is grabbing data out of the *population*. *Population* is the imaginary urn from which our data has been, or will be drawn. 

## PD for rolling two dice
### 

Let's create the following *empirical distribution* for rolling two dice.

```{r}
set.seed(1)

emp_dist_dice <- tibble(ID = 1:100) |> 
  mutate(die_1 = map_dbl(ID, ~ sample(c(1:6), size = 1))) |> 
  mutate(die_2 = map_dbl(ID, ~ sample(c(1:6), size = 1))) |> 
  mutate(sum = die_1 + die_2) |> 
  ggplot(aes(x = sum)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 1, 
                   color = "white") +
    labs(title = "Empirical Probability Distribution",
         subtitle = "Sum from rolling two dice, replicated one hundred times",
         x = "Outcome\nSum of Two Die",
         y = "Probability") +
    scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) +
    scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
    theme_classic()

emp_dist_dice
```

### Exercise 1

Create a tibble with variable `ID`, and the we make a list of values from 1 to 100 for the variable `ID`.

```{r pd-for-rolling-two-dice-1, exercise = TRUE}

```

```{r pd-for-rolling-two-dice-1-hint-1, eval = FALSE}
tibble(ID = ... : ...)
```

```{r pd-for-rolling-two-dice-1-test, include = FALSE}
tibble(ID = 1:100)
```

### 

`tibble()` function provides us a framework to generate our data, this function will be used throughout this tutorial.

### Exercise 2

Now let's pipe the tibble to the `map_dbl()` function to create the results for an random dice rolling experiment. It will include two arguments, one is the data source, which in this case is `ID`, and the second is `~sample(c(1:6), size = 1)`.

```{r pd-for-rolling-two-dice-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>


```{r pd-for-rolling-two-dice-2-hint-1, eval = FALSE}
...|>
map_dbl(ID, ~sample(c(...:...), size = 1))
```

```{r pd-for-rolling-two-dice-2-test, include = FALSE}
# tibble(ID = 1:100) |>
#                       map_dbl(ID, ~sample(c(1:6), size = 1))
```

This may return an error, but you may still continue on to the next exercise where the code should run without any errors.

### 

We use 1 through 6 to generate any one of the 6 sides of the dice. Size is one because we only want one side.

### Exercise 3

Now let's pipe the tibble to `mutate()`. Assign the `map_dbl` function we made above to an value called `die_1`.

```{r pd-for-rolling-two-dice-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-rolling-two-dice-3-hint-1, eval = FALSE}
tibble(ID = 1:100) |>
                     mutate(... = map_dbl(ID, ~sample(c(1:6), size = 1)))
```

```{r pd-for-rolling-two-dice-3-test, include = FALSE}
tibble(ID = 1:100) |>
                     mutate(die_1 = map_dbl(ID, ~sample(c(1:6), size = 1)))
```

### Exercise 4

Now copy and paste the results from above, and do the exact same thing again but instead, change the name from `die_1` to `die_2`, because we need the results for two dices.

```{r pd-for-rolling-two-dice-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-rolling-two-dice-4-hint-1, eval = FALSE}
...|>
mutate(...,
       ... =map_dbl(ID, ~sample(c(...:...), size = 1)))
```

```{r pd-for-rolling-two-dice-4-test, include = FALSE}
tibble(ID = 1:100) |>
                     mutate(die_1 = map_dbl(ID, ~sample(c(1:6), size = 1)),
                            die_2 = map_dbl(ID, ~sample(c(1:6), size = 1)))
```

### Exercise 5

Use the `mutate()` function once again, name the value of the sum of `die_1` and `die_2` to `"sum"`.

```{r pd-for-rolling-two-dice-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-rolling-two-dice-5-hint-1, eval = FALSE}
...|>
mutate(...,
       ...,
       sum = die_1 + die_2)
```

```{r pd-for-rolling-two-dice-5-test, include = FALSE}
tibble(ID = 1:100) |>
                     mutate(die_1 = map_dbl(ID, ~sample(c(1:6), size = 1)),
                            die_2 = map_dbl(ID, ~sample(c(1:6), size = 1)),
                            sum = die_1+die_2)
```

### Exercise 6

Now use `ggplot()` to graph the Empirical Distribution, set `x = sum` within `aes()`, and then add a layer of `geom_histogram()`

```{r pd-for-rolling-two-dice-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-rolling-two-dice-6-hint-1, eval = FALSE}
...|>
ggplot(aes(...))+
  geom_histogram()
```

```{r pd-for-rolling-two-dice-6-test, include = FALSE}
tibble(ID = 1:100) |>
                     mutate(die_1 = map_dbl(ID, ~sample(c(1:6), size = 1)),
                            die_2 = map_dbl(ID, ~sample(c(1:6), size = 1)),
                            sum = die_1+die_2) |>
                     ggplot(aes(x = sum)) + 
                      geom_histogram()
```

### Exercise 7

Within `geom_histogram()`, inside `aes()`, set the argument `y` equal to  `after_stat(count/sum(count))` to put percents on the y-axis.

```{r pd-for-rolling-two-dice-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-rolling-two-dice-7-hint-1, eval = FALSE}
... +
    geom_histogram(aes(y = after_stat(...)))
```

```{r pd-for-rolling-two-dice-7-test, include = FALSE}
tibble(ID = 1:100) |>
                     mutate(die_1 = map_dbl(ID, ~sample(c(1:6), size = 1)),
                            die_2 = map_dbl(ID, ~sample(c(1:6), size = 1)),
                            sum = die_1+die_2) |>
                     ggplot(aes(x = sum)) + 
                      geom_histogram(aes(y = after_stat(count/sum(count))))
```

### Exercise 8

Also set `binwidth` to `0.5` and `color` to `"white"` within `geom_histogram()`.

```{r pd-for-rolling-two-dice-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-rolling-two-dice-8-hint-1, eval = FALSE}
... +
    geom_histogram(..., 
                   binwidth = ..., 
                   color = "..."))
```

```{r pd-for-rolling-two-dice-8-test}
tibble(ID = 1:100) |>
                     mutate(die_1 = map_dbl(ID, ~sample(c(1:6), size = 1)),
                            die_2 = map_dbl(ID, ~sample(c(1:6), size = 1)),
                            sum = die_1+die_2) |>
                     ggplot(aes(x = sum)) + 
                      geom_histogram(aes(y = after_stat(count/sum(count))),
                                     binwidth = 0.5,
                                     color = "white")
```

### Exercise 9

Now use `scale_x_continuous()` so the x-axis has `breaks` to the sequence between 2 and 12 common difference is 1 using `seq()`. Set the `labels` for the breaks from 2 to 12.

```{r pd-for-rolling-two-dice-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-rolling-two-dice-9-hint-1, eval = FALSE}
... +
  scale_x_continuous(breaks = seq(...,..., ...), labels = ...:...) 
```

```{r pd-for-rolling-two-dice-9-test, include = FALSE}
tibble(ID = 1:100) |>
                     mutate(die_1 = map_dbl(ID, ~sample(c(1:6), size = 1)),
                            die_2 = map_dbl(ID, ~sample(c(1:6), size = 1)),
                            sum = die_1+die_2) |>
                     ggplot(aes(x = sum)) + 
                      geom_histogram(aes(y = after_stat(count/sum(count))),
                                     binwidth = 0.5,
                                     color = "white") + 
                      scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) 
```

### Exercise 10

Now use `scale_y_continuous()` to put the x-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to `1`.

```{r pd-for-rolling-two-dice-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-rolling-two-dice-10-hint-1, eval = FALSE}
... + 
  scale_y_continuous(labels = scales::percent_format(...))
```

```{r pd-for-rolling-two-dice-10-test, include = FALSE}
tibble(ID = 1:100) |>
                     mutate(die_1 = map_dbl(ID, ~sample(c(1:6), size = 1)),
                            die_2 = map_dbl(ID, ~sample(c(1:6), size = 1)),
                            sum = die_1+die_2) |>
                     ggplot(aes(x = sum)) + 
                      geom_histogram(aes(y = after_stat(count/sum(count))),
                                     binwidth = 0.5,
                                     color = "white") + 
                      scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) +
                      scale_y_continuous(labels = scales::percent_format(accuracy = 1))
```

### Exercise 11

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels. Also add the layer `theme_classic()`.

```{r pd-for-rolling-two-dice-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-rolling-two-dice-11-test}
tibble(ID = 1:100) |> 
  mutate(die_1 = map_dbl(ID, ~ sample(c(1:6), size = 1))) |> 
  mutate(die_2 = map_dbl(ID, ~ sample(c(1:6), size = 1))) |> 
  mutate(sum = die_1 + die_2) |> 
  ggplot(aes(x = sum)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 1, 
                   color = "white") +
    labs(title = "Empirical Probability Distribution",
         subtitle = "Sum from rolling two dice, replicated one hundred times",
         x = "Outcome\nSum of Two Die",
         y = "Probability") +
    scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) +
    scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
    theme_classic()
```

Reminder: Your plot should look similar to the the one below. 

```{r}
emp_dist_dice
```

## PD for engine displacement
### 

Let's create the following *empirical distribution* about the "engine displacement of the next front-wheel drive car you'll see" using the data from the `mpg` dataset.

```{r}
emp_mpg <- mpg |>
  filter(drv == "f", cty >= 16) |>
  select(displ)|>
  drop_na() |>
  ggplot(aes(x = displ)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                 binwidth = 1, 
                 color = "white")+
  labs(title = "Empirical Probability Distribution",
       subtitle = "Engine Displacement for front-wheel drive cars from mpg",
       x = "Engine Displacement",
       y = "Probability",caption = "Source:mpg") +
  scale_y_continuous(labels =
                      scales::percent_format(accuracy = 1)) +
  theme_classic()

emp_mpg
```

### Exercise 1

Run `glimpse()` on `mpg`.

```{r pd-for-engine-displacement-1, exercise = TRUE}

```

```{r pd-for-engine-displacement-1-hint-1, eval = FALSE}
glimpse(...)
```

```{r pd-for-engine-displacement-1-test, include = FALSE}
glimpse(mpg)
```

There are all sorts of columns in this data set, but the two that we actually care about are `drv` and `cty`.
 
### Exercise 2

Start a new pipe with `mpg`, use `filter()` to filter the rows where `drv` is equal to `"f"`, and `cty` is greater than or equal to `16`.

```{r pd-for-engine-displacement-2, exercise = TRUE}

```

```{r pd-for-engine-displacement-2-hint-1, eval = FALSE}
mpg |>
  filter(drv == ..., cty >= ...) 
```

```{r pd-for-engine-displacement-2-test, include = FALSE}
mpg |>
  filter(drv == "f", cty >= 16) 
```

### Exercise 3

Continuing with the previous code, use `select()` to pick out the `displ` column which is what we want. Then use `drop_na()` to drop the rows that contains NA which we don't want. 
```{r pd-for-engine-displacement-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-engine-displacement-3-hint-1, eval = FALSE}
...|>
  select(...)|>
  drop_na()
```

```{r pd-for-engine-displacement-3-test, include = FALSE}
mpg |>
  filter(drv == "f", cty >= 16) |>
  select(displ)|>
  drop_na()
```

### Exercise 4

After the previous code, use `ggplot()` and `geom_histogram()` to graph out the distribution, set `x` equal to `"displ"` within `aes()` in `ggplot()`.

```{r pd-for-engine-displacement-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-engine-displacement-4-hint-1, eval = FALSE}
...|>
  ggplot(aes(x = ...)) +
  geom_histogram()
```

```{r pd-for-engine-displacement-4-test, include = FALSE}
mpg |>
  filter(drv == "f", cty >= 16) |>
  select(displ)|>
  drop_na() |>
  ggplot(aes(x = displ)) +
  geom_histogram()
```

### Exercise 5

Within `geom_histogram()`, use `aes()` . Inside `aes()`, set `y` equal to `after_stat()` with the argument `count/sum(count)` to put percents on the y-axis.

```{r pd-for-engine-displacement-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-engine-displacement-5-hint-1, eval = FALSE}
... +
    geom_histogram(aes(... = after_stat(...))) 
```

```{r pd-for-engine-displacement-5-test, include = FALSE}
mpg |>
  filter(drv == "f", cty >= 16) |>
  select(displ)|>
  drop_na() |>
  ggplot(aes(x = displ)) +
    geom_histogram(aes(y = after_stat(count/sum(count)))) 
```

### Exercise 6

Also set `binwidth` to `0.5` and `color` to "white" within `geom_histrogram()`.

```{r pd-for-engine-displacement-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-engine-displacement-6-hint-1, eval = FALSE}
... +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = ..., 
                   ... = "white") 
```

```{r pd-for-engine-displacement-6-test, include = FALSE}
mpg |>
  filter(drv == "f", cty >= 16) |>
  select(displ)|>
  drop_na() |>
  ggplot(aes(x = displ)) +
    geom_histogram(aes(y = after_stat(count/sum(count))),
                   binwidth = 0.5,
                   color = "white") 
```

### Exercise 7

Now use `scale_y_continuous()` to put the y-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1.

```{r pd-for-engine-displacement-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pd-for-engine-displacement-7-hint-1, eval = FALSE}
... + 
  scale_y_continuous(... = scales::percent_format(...))
```

```{r pd-for-engine-displacement-7-test, include = FALSE}
mpg |>
  filter(drv == "f", cty >= 16) |>
  select(displ)|>
  drop_na() |>
  ggplot(aes(x = displ)) +
    geom_histogram(aes(y = after_stat(count/sum(count))),
                   binwidth = 0.5,
                   color = "white") + 
    scale_y_continuous(labels = scales::percent_format(accuracy = 1))
```

### Exercise 8

Finally, use `labs()` to add the appropriate title, subtitle, axis labels, and caption. Also add the layer `theme_classic()`.

```{r pd-for-engine-displacement-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

Reminder: Your plot should look exactly like this one because we used the exact same data from mpg.

```{r pd-for-engine-displacement-8-test, include = FALSE}
mpg |>
  filter(drv == "f", cty >= 16) |>
  select(displ)|>
  drop_na() |>
  ggplot(aes(x = displ)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                 binwidth = 1, 
                 color = "white")+
  labs(title = "Empirical Probability Distribution",
       subtitle = "Engine Displacement for front-wheel drive cars from mpg",
       x = "Engine Displacement",
       y = "Probability",caption = "Source:mpg") +
  scale_y_continuous(labels =
                      scales::percent_format(accuracy = 1)) +
  theme_classic()
```

```{r}
emp_mpg
```

## List-columns and map functions
### 

We need to expand our collection of R tricks by learning about list-columns and `map_*` functions. Recall that a list is different from an atomic vector. In atomic vectors, each element of the vector has the same type. Lists, however, can contain objects of different types, including vectors and even more complex object, such as elements.

### Exercise 1

Use `c()` to combine the following numbers : 4, 16, 9

```{r listcolumns-and-map-functions-1, exercise = TRUE}

```

```{r listcolumns-and-map-functions-1-hint-1, eval = FALSE}
c(..., ..., ...)
```

```{r listcolumns-and-map-functions-1-test, include = FALSE}
c(4, 16, 9)
```

### 

`c()` combines its arguments to form a vector. 

### Exercise 2

Now use `c()` to combine two letters ("A" and "Z") into a single vector.

```{r listcolumns-and-map-functions-2, exercise = TRUE}

```

```{r listcolumns-and-map-functions-2-hint-1, eval = FALSE}
c(..., ...)
```

```{r listcolumns-and-map-functions-2-test, include = FALSE}
c("A", "Z")
```

### 

`c()` is the most commonly used function for creating vectors.

### Exercise 3

Create a `list()` with two elements: the first element is the combine numbers from first exercise and the second is the combine letters from second exercise.

```{r listcolumns-and-map-functions-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map-functions-3-hint-1, eval = FALSE}
list(c(...), c(...))
```

```{r listcolumns-and-map-functions-3-test, include = FALSE}
list(c(4, 16, 9), c("A", "Z"))
```

### 

Any function that returns multiple values can be used to create a list output by wrapping that returned object with `list()`.

### Exercise 4

Now assign the list we just created to a variable `x`, then run `x[[1]]`. It should returns the first element which are the 3 numbers.

```{r listcolumns-and-map-functions-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map-functions-4-hint-1, eval = FALSE}
x <- list(c(...),c(...))
x[[...]]
```

```{r listcolumns-and-map-functions-4-test, include = FALSE}
x <- list(c(4, 16, 9), c("A", "Z"))
x[[1]]
```

### 

We use `[[]]` to extract specific elements.

### Exercise 5

Use `rnorm()` to generate a vector of 10 random numbers, with mean 0 and standard deviation 1. 

```{r listcolumns-and-map-functions-5, exercise = TRUE}

```

```{r listcolumns-and-map-functions-5-hint-1, eval = FALSE}
rnorm(10)
```

```{r listcolumns-and-map-functions-5-test, include = FALSE}
rnorm(10)
```

### 

You could do something like `rnorm(n = 10, mean = 0, sd = 1)`, but since we are using the default values of `mean` and `sd`, we can simply do `rnorm(10)`.

### Exercise 6

Use the `range()` to calculate the range of `rnorm(10)`.

```{r listcolumns-and-map-functions-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map-functions-6-hint-1, eval = FALSE}
range(rnorm(10))
```

```{r listcolumns-and-map-functions-6-test, include = FALSE}
range(rnorm(10))
```

### 

`range()` returns a *vector* containing the minimum and maximum of all the given arguments.

### Exercise 7

Run `list()` with `range(rnorm(10)` as its only input.

```{r listcolumns-and-map-functions-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map-functions-7-hint-1, eval = FALSE}
list(range(rnorm(...)))
```

```{r listcolumns-and-map-functions-7-test, include = FALSE}
list(range(rnorm(10)))
```

### 

In both this question and the previous one, we used `list()` to create an object with two elements. To learn more about [How To Work With List Columns](https://www.rstudio.com/resources/webinars/how-to-work-with-list-columns/)

### Exercise 8

<!-- DK: Sloppy. -->

Now take the list we created above and assign it into a tibble using `tibble()` in which the column name is `col_1`.

```{r listcolumns-and-map-functions-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map-functions-8-hint-1, eval = FALSE}
tibble(col_1 = list(range(rnorm(...))))
```

```{r listcolumns-and-map-functions-8-test, include = FALSE}
tibble(col_1 = list(range(rnorm(10))))
```

### 

Now you have created a list-column which is a 1-by-1 tibble with one observation, which is a list of one element.

### Exercise 9

Pipe your result to `mutate()`. Make a new variable, `col_2`, and set it equal to `map_dbl()`. Set the first argument in `map_dbl` to `col_1`, the second to `sum()`, don't forget the `~` before `sum()`, and the `.` within `sum()`.

```{r listcolumns-and-map-functions-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map-functions-9-hint-1, eval = FALSE}
... |> 
  mutate(col_2= map_dbl(col_1, ~sum(.)))
```

```{r listcolumns-and-map-functions-9-test, include = FALSE}
tibble(col_1 = list(range(rnorm(10)))) |>
                                    mutate(col_2= map_dbl(col_1, ~sum(.)))
```

### 

We can replace the `~ sum(.)` to simply sum as a statement, but we generally work with formulas more often, so we practice using `~ sum(.)` instead.

### Exercise 10

Let's try using other map_* functions, use `map_int()` to set the first argument to `col_1`, replace `sum()` with `length()`, and assign the `map_int()` to a new column `col_3`.

```{r listcolumns-and-map-functions-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map-functions-10-hint-1, eval = FALSE}
... |> 
  mutate(..., 
         col_3= map_int(..., ~...(.)))
```

```{r listcolumns-and-map-functions-10-test, include = FALSE}
tibble(col_1 = list(range(rnorm(10)))) |> 
  mutate(col_2= map_dbl(col_1, ~sum(.)),
         col_3= map_int(col_1, ~length(.)))
```

### 

Again if we replace `~ length(.)` with just `length`, we would got the same result.

### Exercise 11

Let's try using other map_* functions, use `map_chr()` set the first argument to `col_1`, replace `length()` with `mean()`, and assign the `map_chr()` to a new column `col_4`.

```{r listcolumns-and-map-functions-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map-functions-11-hint-1, eval = FALSE}
... |> 
  mutate(..,
         ...,
         col_4 = map_chr(..., ~...(.)))
```

```{r listcolumns-and-map-functions-11-test, include = FALSE}
tibble(col_1 = list(range(rnorm(10)))) |> 
  mutate(col_2= map_dbl(col_1, ~sum(.)),
         col_3= map_int(col_1, ~length(.)),
         col_4 = map_chr(col_1, ~mean(.)))
```

### 

The reason for why we are doing these in almost the same exercise is to show you how different map_* functions would return different vectors for the new column we create. To learn more about the other map functions check [Map Functions](https://r4ds.had.co.nz/iteration.html?q=map#the-map-functions).

### Exercise 12

Create a tibble using `tibble()`, set the first column `ID` equal to a set of integers from 1 to 10. 

```{r listcolumns-and-map-functions-12, exercise = TRUE}

```

```{r listcolumns-and-map-functions-12-hint-1, eval = FALSE}
tibble(ID = 1:10)
```

```{r listcolumns-and-map-functions-12-test, include = FALSE}
tibble(ID = 1:10)
```

### 

We can get the consecutive integers we want by using `:` instead of `c()`.

### Exercise 13

After the previous code, pipe `mutate()` to create a new column called `N`, set `N` equal to `sample(rnorm(10),size=1)`. 

```{r listcolumns-and-map-functions-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map-functions-13-hint-1, eval = FALSE}
... |>
  mutate(N = sample(rnorm(...),size = ...))
```

```{r listcolumns-and-map-functions-13-test, include = FALSE}
tibble(ID = 1:10) |>
  mutate(N = sample(rnorm(10),size=1))
```

### 

Note how all `N` is equal, essentially what happened here is `N` calculates it self using the `sample()` function and copies it 10 times to match the `ID` column.

### Exercise 14

Create an new column called `Y`. Copy and paste the left-hand side of `N` but wrap `map_dbl` around it. Add `~` in front of sample.

```{r listcolumns-and-map-functions-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map-functions-14-hint-1, eval = FALSE}
tibble(ID = 1:10) |>
  mutate(N = sample(rnorm(10),size=1)) |>
  mutate(Y = map_dbl(ID, ~ sample(rnorm(...),size=...)))
```

```{r listcolumns-and-map-functions-14-test, include = FALSE}
tibble(ID = 1:10) |>
  mutate(N = sample(rnorm(10),size=1)) |>
  mutate(Y = map_dbl(ID, ~ sample(rnorm(10), size = 1)))
```

### 

When we add on the `map_* ()` function to the mutate, it grabs the data, in this case `ID`, and it deals with each one of the data using the formula in the second statement `~sample()`, that's why we would get different results for each ID in the Y column but not in the `N` column.

<!-- ## Two models -->
<!-- ###  -->

<!-- In a basic scenario, there are two models: either you have Probaphobia (fear of probability) or you don't. We're uncertain which one applies, but these are the only possibilities. -->

<!-- ###  -->

<!-- Let's create the following *joint and conditional* probability tibble about Probaphobia. There is then a 50% chance that you test positive and a 50% chance you test negative. -->

<!-- ```{r} -->
<!-- jd_disease <- tibble(ID = 1:10000,  -->
<!--                      have_disease = rep(c(TRUE, FALSE),  -->
<!--                                         5000)) |> -->
<!--   mutate(positive_test = if_else(have_disease, -->
<!--                                  map_int(have_disease, ~ rbinom(n = 1, size = 1, p = 0.99)), -->
<!--                                  map_int(have_disease, ~ rbinom(n = 1, size = 1, p = 0.5)))) -->

<!-- jd_disease -->
<!-- ``` -->

<!-- ### Exercise 1 -->

<!-- Use `tibble()` and set `ID` from 1 to 10000. -->

<!-- ```{r two-models-1, exercise = TRUE} -->

<!-- ``` -->

<!-- ```{r two-models-1-hint-1, eval = FALSE} -->
<!-- tibble(ID = ...) -->
<!-- ``` -->

<!-- ```{r two-models-1-test, include = FALSE} -->
<!-- tibble(ID = 1:1000) -->
<!-- ``` -->

<!-- ###  -->

<!-- The first step is to simply create an tibble that consists of the simulated data we need to plot our distribution.  -->

<!-- ### Exercise 2 -->

<!-- Within `tibble()` set `have_disease` to `rep(c(TRUE, FALSE), 5000)`. -->

<!-- ```{r two-models-2, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r two-models-2-hint-1, eval = FALSE} -->
<!-- tibble(..., have_disease = rep(c(TRUE, FALSE), 5000)) -->
<!-- ``` -->

<!-- ```{r two-models-2-test, include = FALSE} -->
<!-- tibble(ID = 1:10000,  -->
<!--                      have_disease = rep(c(TRUE, FALSE),  -->
<!--                                         5000)) -->
<!-- ``` -->

<!-- ###  -->

<!-- We have two different probabilities and they are completely separate from each other and we want to keep the two probabilities and the disease results in two and only two columns so that we can graph using the `ggplot()` function. -->

<!-- ### Exercise 3 -->

<!-- Start a pipe with the above code and `mutate()` with `positive_test` set to `if_else(have_disease)`. -->

<!-- ```{r two-models-3, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r two-models-3-hint-1, eval = FALSE} -->
<!-- ... |> -->
<!--   mutate(positive_test = if_else(...)) -->
<!-- ``` -->

<!-- ```{r two-models-3-test, include = FALSE} -->
<!--  # tibble(ID = 1:10000,  -->
<!--  #        have_disease = rep(c(TRUE,FALSE), 5000)) |> -->
<!--  #   mutate(positive_test = if_else(have_disease)) -->
<!-- ``` -->

<!-- ### Exercise 4 -->

<!-- Finally let's add two `map_int()`'s with `have_disease` and `rbinom()` into `if_else`. In `rbinom()` set `n` to 1, `size` to 1, and `prob` to `0.99` for the first and `0.5` for the second. -->

<!-- ```{r two-models-4, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r two-models-4-hint-1, eval = FALSE} -->
<!-- ... |> -->
<!--   mutate(..., -->
<!--          map_int(..., ~ rbinom(n = 1, size = ..., p = 0.99)), -->
<!--          map_int(..., ~ rbinom(n = 1, size = ..., p = 0.5)))) -->
<!-- ``` -->

<!-- ```{r two-models-4-test, include = FALSE} -->
<!--  # tibble(ID = 1:10000, have_disease = rep(c(TRUE,FALSE), 5000)) |> -->
<!--  #   mutate(positive_test = if_else(have_disease), -->
<!--  #          map_int(have_disease ~ rbinom(n = 1, size = 1, p = .99)), -->
<!--  #          map_int(have_disease ~ rbinom(n = 1, size = 1, p = .05))) -->
<!-- ``` -->

<!-- ###  -->

<!-- We use the `rep` and `seq` functions when creating the table. The `seq` function sets the sequence we wants, in this case it is only two numbers, 0.01 (99% accuracy for testing negative if no disease, therefore 1% for testing positive if no disease) and 0.5 (50% accuracy for testing positive/negative if have disease), then we used the `rep` functions to repeat the process 10,000 times for each probability, in total 20,000 times. -->

<!-- ### Exercise 5 -->

<!-- Take the above code and set it to the `jd_disease` variable. -->

<!-- ```{r two-models-5, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r two-models-5-hint-1, eval = FALSE} -->
<!-- jd_disease <- ...  -->
<!-- ``` -->

<!-- ```{r two-models-5-test, include = FALSE} -->
<!--  # jd_disease <- tibble(ID = 1:10000, have_disease = rep(c(TRUE,FALSE), 5000)) |> -->
<!--  #   mutate(positive_test = if_else(have_disease), -->
<!--  #          map_int(have_disease ~ rbinom(n = 1, size = 1, p = .99)), -->
<!--  #          map_int(have_disease ~ rbinom(n = 1, size = 1, p = .05))) -->
<!-- ``` -->

<!-- ### Exercise 6 -->

<!-- Let's create an *unnormalized conditional distribution*.  -->

<!-- ```{r} -->
<!--  jd_disease |> -->
<!--    filter(positive_test == 1)|> -->
<!--    ggplot(aes(x = have_disease)) +  -->
<!--    geom_bar()+ -->
<!--     labs(title = "Disease Status Given Positive Test", -->
<!--          subtitle = "Almost all of the cases were infected", -->
<!--          x = "Disease Status", -->
<!--          y = "Count") + -->
<!--     scale_x_discrete(breaks = c(FALSE, TRUE), -->
<!--                      labels = c("Healthy", "Infected")) -->
<!-- ``` -->

<!-- Start a pipe with the `jd_disease` to `filter()` and only include `positive_test` equal to 1. -->

<!-- ```{r two-models-6, exercise = TRUE} -->

<!-- ``` -->

<!-- ```{r two-models-6-hint-1, eval = FALSE} -->
<!-- ... |>  -->
<!--   filter(... == 1) -->
<!-- ``` -->

<!-- ```{r two-models-6-test, include = FALSE} -->
<!--  jd_disease |> -->
<!--    filter(positive_test == 1) -->
<!-- ``` -->

<!-- ###  -->

<!-- Since the test is not always accurate, you cannot be 100% certain that you have it. Here we are isolating the slice where the test result equals 1 (meaning positive). -->

<!-- ### Exercise 7 -->

<!-- Continue the pipe from above and `ggplot()` and within `aes()` set `x` to `have_disease`. -->

<!-- ```{r two-models-7, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r two-models-7-hint-1, eval = FALSE} -->
<!-- ... |>  -->
<!--   ggplot(aes(x = ...)) -->
<!-- ``` -->

<!-- ```{r two-models-7-test, include = FALSE} -->
<!--  jd_disease |> -->
<!--    filter(positive_test == 1)|> -->
<!--    ggplot(aes(x = have_disease)) -->
<!-- ``` -->

<!-- ### Exercise 8 -->

<!-- Add `geom_bar()` to the view the following graph. -->

<!-- ```{r two-models-8, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r two-models-8-hint-1, eval = FALSE} -->
<!-- ... + -->
<!--     geom_bar() -->
<!-- ``` -->

<!-- ```{r two-models-8-test, include = FALSE} -->
<!--  jd_disease |> -->
<!--    filter(positive_test == 1)|> -->
<!--    ggplot(aes(x = have_disease)) +  -->
<!--    geom_bar() -->
<!-- ``` -->

<!-- ### Exercise 9 -->

<!-- Now we want to add labels with `labs()`. Set `title` to "Disease Status Given Positive Test", `subtitle` to "Almost all of the cases were infected", `x` to "Disease Status", and `y` to "Count"`. -->

<!-- ```{r two-models-9, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r two-models-9-hint-1, eval = FALSE} -->
<!-- ... + -->
<!--     labs(title = ..., -->
<!--          ... = "Almost all of the cases were infected", -->
<!--          x = ..., -->
<!--          y = ...) -->
<!-- ``` -->

<!-- ```{r two-models-9-test, include = FALSE} -->
<!--  jd_disease |> -->
<!--    filter(positive_test == 1)|> -->
<!--    ggplot(aes(x = have_disease)) +  -->
<!--    geom_bar()+ -->
<!--     labs(title = "Disease Status Given Positive Test", -->
<!--          subtitle = "Almost all of the cases were infected", -->
<!--          x = "Disease Status", -->
<!--          y = "Count") -->

<!-- ``` -->

<!-- ### Exercise 10 -->

<!-- Let's add `scale_x_discrete()` and set `breaks` to `c(FALSE, TRUE)`. -->

<!-- ```{r two-models-10, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r two-models-10-hint-1, eval = FALSE} -->
<!-- ... + -->
<!--     scale_x_discrete(... = c(..., ...)) -->
<!-- ``` -->

<!-- ```{r two-models-10-test, include = FALSE} -->
<!--  jd_disease |> -->
<!--    filter(positive_test == 1)|> -->
<!--    ggplot(aes(x = have_disease)) +  -->
<!--    geom_bar()+ -->
<!--     labs(title = "Disease Status Given Positive Test", -->
<!--          subtitle = "Almost all of the cases were infected", -->
<!--          x = "Disease Status", -->
<!--          y = "Count") + -->
<!--     scale_x_discrete(breaks = c(FALSE, TRUE)) -->
<!-- ``` -->

<!-- ###  -->

<!-- We want to change the labels on the bottom of the graph which can be done by recognizing that the `breaks` are `FALSE` and `TRUE` on the bottom. -->

<!-- ### Exercise 11 -->

<!-- Continue the `scale_x_discrete()` function by adding `labels` set to `c("Healthy", "Infected")`. -->

<!-- ```{r two-models-11, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r two-models-11-hint-1, eval = FALSE} -->
<!-- ... + -->
<!--     scale_x_discrete(..., -->
<!--                      labels = c("Healthy", "Infected")) -->
<!-- ``` -->

<!-- ```{r two-models-11-test, include = FALSE} -->
<!--  jd_disease |> -->
<!--    filter(positive_test == 1)|> -->
<!--    ggplot(aes(x = have_disease)) +  -->
<!--    geom_bar()+ -->
<!--     labs(title = "Disease Status Given Positive Test", -->
<!--          subtitle = "Almost all of the cases were infected", -->
<!--          x = "Disease Status", -->
<!--          y = "Count") + -->
<!--     scale_x_discrete(breaks = c(FALSE, TRUE), -->
<!--                      labels = c("Healthy", "Infected")) -->
<!-- ``` -->

<!-- ###  -->

<!-- Through labels we are able to change the label `FALSE` to "Healthy" and `TRUE` to "Infected". -->

<!-- ###  -->

<!-- Most people who test positive are infected. This is a result for common diseases like the common cold. -->

<!-- ### Exercise 12 -->

<!-- Let's use the data from above to create a *conditional distribution*. -->

<!-- ```{r} -->
<!-- jd_disease |>  -->
<!--   filter(positive_test == 1) |>  -->
<!--   ggplot(aes(have_disease)) + -->
<!--     geom_bar(aes(y = after_stat(count/sum(count)), -->
<!--                  color = "white")) +  -->
<!--     labs(title = "Posterior for Probaphobia Conditional on Positive Test", -->
<!--     x = "Probaphobia Status", -->
<!--     y = "Probability") + -->
<!--     scale_x_discrete(breaks = c(FALSE, TRUE), -->
<!--                      labels = c("Healthy", "Infected")) + -->
<!--     scale_y_continuous(labels = scales::percent_format(accuracy = 1)) -->
<!-- ``` -->

<!-- Add `geom_bar()` and within `aes()` set `y` to `after_stat(count/sum(count))`. -->

<!-- ```{r two-models-12, exercise = TRUE} -->
<!-- jd_disease |>  -->
<!--   filter(positive_test == 1) |>  -->
<!--   ggplot(aes(have_disease)) -->
<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r two-models-12-hint-1, eval = FALSE} -->
<!-- jd_disease |>  -->
<!--   filter(positive_test == 1) |>  -->
<!--   ggplot(aes(have_disease)) + -->
<!--     geom_bar(aes(y = ...))) -->
<!-- ``` -->

<!-- ```{r two-models-12-test, include = FALSE} -->
<!-- jd_disease |>  -->
<!--   filter(positive_test == 1) |>  -->
<!--   ggplot(aes(have_disease)) + -->
<!--     geom_bar(aes(y = after_stat(count/sum(count)))) -->
<!-- ``` -->

<!-- ###  -->

<!-- `filter()` transforms a *joint distribution* into a *conditional distribution*. We will turn the *unnormalized distribution* into a *posterior probability distribution*. -->

<!-- ### Exercise 13 -->

<!-- In `geom_bar()` set `color` to "white". -->

<!-- ```{r two-models-13, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r two-models-13-hint-1, eval = FALSE} -->
<!-- ... + -->
<!--     geom_bar(aes(y = ...)),  -->
<!--              color = "white") -->
<!-- ``` -->

<!-- ```{r two-models-13-test, include = FALSE} -->
<!-- jd_disease |>  -->
<!--   filter(positive_test == 1) |>  -->
<!--   ggplot(aes(have_disease)) + -->
<!--     geom_bar(aes(y = after_stat(count/sum(count)), -->
<!--                  color = "white")) -->
<!-- ``` -->

<!-- ###  -->

<!-- If we zoom in on the plot, about 70% of people who tested positive have the disease and 30% who tested positive do not have the disease. In this case, we are focusing on the one slice of the probability distribution where the test result was positive. -->

<!-- ### Exercise 14 -->

<!-- Let's add labels to this graph through `labs()`. Set `title` to "Posterior for Probaphobia Conditional on Positive Test", `x` to "Probaphobia Status", and `y` to "Probability". -->

<!-- ```{r two-models-14, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r two-models-14-hint-1, eval = FALSE} -->
<!-- ... + -->
<!--     labs(... = "Posterior for Probaphobia Conditional on Positive Test", -->
<!--     x = ..., -->
<!--     y = ...) -->
<!-- ``` -->

<!-- ```{r two-models-14-test, include = FALSE} -->
<!-- jd_disease |>  -->
<!--   filter(positive_test == 1) |>  -->
<!--   ggplot(aes(have_disease)) + -->
<!--     geom_bar(aes(y = after_stat(count/sum(count)), -->
<!--                  color = "white")) +  -->
<!--     labs(title = "Posterior for Probaphobia Conditional on Positive Test", -->
<!--     x = "Probaphobia Status", -->
<!--     y = "Probability") -->
<!-- ``` -->

<!-- ### Exercise 15 -->

<!-- Now we want to add `scale_x_discrete()`. Set `breaks` to `c(FALSE, TRUE)` and `labels` to `c("Healthy", "Infected")`. -->

<!-- ```{r two-models-15, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r two-models-15-hint-1, eval = FALSE} -->
<!-- ... + -->
<!--     scale_x_discrete(breaks = c(..., ...), -->
<!--                      labels = c("...", "...")) -->
<!-- ``` -->

<!-- ```{r two-models-15-test, include = FALSE} -->

<!-- jd_disease |>  -->
<!--   filter(positive_test == 1) |>  -->
<!--   ggplot(aes(have_disease)) + -->
<!--     geom_bar(aes(y = after_stat(count/sum(count)), -->
<!--                  color = "white")) +  -->
<!--     labs(title = "Posterior for Probaphobia Conditional on Positive Test", -->
<!--     x = "Probaphobia Status", -->
<!--     y = "Probability") + -->
<!--     scale_x_discrete(breaks = c(FALSE, TRUE), -->
<!--                      labels = c("Healthy", "Infected")) -->

<!-- ``` -->

<!-- ###  -->

<!-- There are two disease outcomes: positive or negative. By isolating a section, we are looking at a *conditional distribution*. Conditional on a positive test, you can visualize the likelihood of actually having the disease versus not. -->

<!-- ### Exercise 16 -->

<!-- Continue by adding `scale_y_continuous()` and set `labels` to `scales::percent_format(accuracy = 1)`. -->

<!-- ```{r two-models-16, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r two-models-16-hint-1, eval = FALSE} -->
<!-- ... + -->
<!--     scale_y_continuous(labels = ...) -->
<!-- ``` -->

<!-- ```{r two-models-16-test, include = FALSE} -->
<!-- jd_disease |>  -->
<!--   filter(positive_test == 1) |>  -->
<!--   ggplot(aes(have_disease)) + -->
<!--     geom_bar(aes(y = after_stat(count/sum(count)), -->
<!--                  color = "white")) +  -->
<!--     labs(title = "Posterior for Probaphobia Conditional on Positive Test", -->
<!--     x = "Probaphobia Status", -->
<!--     y = "Probability") + -->
<!--     scale_x_discrete(breaks = c(FALSE, TRUE), -->
<!--                      labels = c("Healthy", "Infected")) + -->
<!--     scale_y_continuous(labels = scales::percent_format(accuracy = 1)) -->
<!-- ``` -->

<!-- ###  -->

<!-- With a positive test, you can be almost 70% sure that you have Probaphobia, however there is a good chance about 30% that you receive a false positive, so donâ€™t worry too much there is still about a third of hope that you get the wrong result. -->

<!-- ## Three models  -->
<!-- ###  -->

<!-- Let's create the following *joint distribution* of the number of white marbles in a bag and the number of white marbles pulled out in the sample. -->

<!-- ```{r} -->
<!-- joint_p <- tibble(in_bag = rep(c(0, 1, 2), 1000)) |> -->
<!--   mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1,  -->
<!--                                               size = 3,  -->
<!--                                               p = ./2))) |> -->
<!--   ggplot(aes(x = in_sample, y = in_bag)) + -->
<!--     geom_jitter(alpha = 0.5) + -->
<!--     labs(title = "Black and White Marbles", -->
<!--          subtitle = "More white marbles in bag mean more white marbles selected", -->
<!--          x = "White Marbles Selected", -->
<!--          y = "White Marbles in the Bag") + -->
<!--     scale_y_continuous(breaks = c(0, 1, 2)) + -->
<!--   theme_classic() -->

<!-- joint_p -->
<!-- ``` -->

<!-- ### Exercise 1 -->

<!-- Create a tibble with one variable `in_bag`. Have `in_bag` take on the values of `rep()`. Within `rep()` use the arguments `0, 1, 2`.  -->

<!-- ```{r three-models-1, exercise = TRUE} -->

<!-- ``` -->

<!-- ```{r three-models-1-hint-1, eval = FALSE} -->
<!-- tibble(in_bag = rep(c(..., ..., ...))) -->
<!-- ``` -->

<!-- ```{r three-models-1-test, include = FALSE} -->
<!-- tibble(in_bag = rep(c(0, 1, 2))) -->
<!-- ``` -->

<!-- ###  -->

<!-- Great. We now have generated the number of white marbles that exist in our bag.  -->

<!-- ### Exercise 2 -->

<!-- Great. Let's have our code run 1000 times. Add the argument 1000 to `rep()` -->

<!-- ```{r three-models-2, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->


<!-- ```{r three-models-2-hint-1, eval = FALSE} -->
<!--  tibble(in_bag = rep(c(0, 1, 2), ...)) -->
<!-- ``` -->

<!-- ```{r three-models-2-test, include = FALSE} -->
<!-- tibble(in_bag = rep(c(0, 1, 2), 1000)) -->
<!-- ``` -->

<!-- ### Exercise 3 -->

<!-- Use `mutate()`, create a new column name `in_sample`, and set `in_sample` equal to `rbinom()` where `n` is set to 1, `size` is set to 3, and `p` is set to `in_bag/2`. Note that this should returns same values for all 3000 rows under `in_sample` -->
<!-- ` -->
<!-- ```{r three-models-3, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r three-models-3-hint-1, eval = FALSE} -->
<!-- ... |> -->
<!--   mutate(in_sample = rbinom(n = 1, size =3 , p = in_bag/2)) -->
<!-- ``` -->

<!-- ```{r three-models-3-test, include = FALSE} -->
<!-- tibble(in_bag = rep(c(0, 1, 2), 1000)) |> -->
<!--   mutate(in_sample = rbinom(n = 1, size =3 , p = in_bag/2)) -->
<!-- ``` -->

<!-- ###  -->

<!-- This is because `rbinom()` only generate 1 values, so *R* copied and paste that value for all rows to match the 3000 values in the first column. -->

<!-- ### Exercise 4 -->

<!-- Now change `in_sample` and set it to the function `map_int()`. The first argument to `map_int()` should be `in_bag`. The second argument should be `rbinom()` where `n` is set to 1, `size` is set to 3, and `p` is set to `./2`. -->

<!-- ```{r three-models-4, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r three-models-4-hint-1, eval = FALSE} -->
<!-- ... |>  -->
<!--   mutate(in_sample = map_int(..., ~ rbinom(...,  -->
<!--                                            ...,  -->
<!--                                            ...))) -->
<!-- ``` -->

<!-- ```{r three-models-4-test, include = FALSE} -->
<!-- tibble(in_bag = rep(c(0, 1, 2), 1000)) |> -->
<!--   mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1,  -->
<!--                                               size = 3,  -->
<!--                                               p = ./2))) -->
<!-- ``` -->

<!-- ###  -->

<!-- The `.` essentially means carrying the data from the first argument (in_bag) to the operation, it is the same as `in_bag/2`. -->

<!-- ### Exercise 5 -->

<!-- Pipe your result into `ggpplot()`. Map `in_sample` to the x-axis and `in_bag` to the y-axis. Also add the layer `geom_jitter()`.  -->

<!-- ```{r three-models-5, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r three-models-5-hint-1, eval = FALSE} -->
<!-- ... |>  -->
<!--   ggplot(aes(x = ..., y = ...)) + -->
<!--     geom_jitter() -->
<!-- ``` -->

<!-- ```{r three-models-5-test, include = FALSE} -->
<!-- tibble(in_bag = rep(c(0, 1, 2), 1000)) |> -->
<!--   mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1,  -->
<!--                                               size = 3,  -->
<!--                                               p = ./2))) |>  -->
<!--   ggplot(aes(x = in_sample, y = in_bag)) + -->
<!--     geom_jitter() -->
<!-- ``` -->

<!-- ### Exercise 6 -->

<!-- Set `alpha` to .5 within `geom_jitter()`.  -->

<!-- ```{r three-models-6, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->


<!-- ```{r three-models-6-hint-1, eval = FALSE} -->
<!-- ... + -->
<!--     geom_jitter(...) -->
<!-- ``` -->

<!-- ```{r three-models-6-test, include = FALSE} -->
<!-- tibble(in_bag = rep(c(0, 1, 2), 1000)) |> -->
<!--   mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1,  -->
<!--                                               size = 3,  -->
<!--                                               p = ./2))) |>  -->
<!--   ggplot(aes(x = in_sample, y = in_bag)) + -->
<!--     geom_jitter(alpha = 0.5) -->
<!-- ``` -->

<!-- ### Exercise 7 -->

<!-- Now use `scale_y_continuous()` to break the y-axis into three values. Within `scale_y_continuous()`, set `breaks` to 0, 1, and 2. -->

<!-- ```{r three-models-7, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r three-models-7-hint-1, eval = FALSE} -->
<!-- ... +  -->
<!--   scale_y_continuous(breaks = c(..., ..., ...)) -->
<!-- ``` -->

<!-- ```{r three-models-7-test, include = FALSE} -->
<!-- tibble(in_bag = rep(c(0, 1, 2), 1000)) |> -->
<!--   mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1,  -->
<!--                                               size = 3,  -->
<!--                                               p = ./2))) |>  -->
<!--   ggplot(aes(x = in_sample, y = in_bag)) + -->
<!--     geom_jitter(alpha = 0.5) +  -->
<!--   scale_y_continuous(breaks = c(0, 1, 2)) -->
<!-- ``` -->

<!-- ###  -->

<!-- Why do we do this? Each value on the y-axis represents a different version or belief about the world. -->

<!-- ### Exercise 8 -->

<!-- Finally, use `labs()` to add the appropriate title, subtitle, and axis labels. Also add the layer `theme_classic()`. -->

<!-- ```{r three-models-8, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->
<!-- Reminder: This is what your plot should look like. -->

<!-- ```{r three-models-8-test, include = FALSE} -->
<!-- tibble(in_bag = rep(c(0, 1, 2), 1000)) |> -->
<!--   mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1,  -->
<!--                                               size = 3,  -->
<!--                                               p = ./2))) |> -->
<!--   ggplot(aes(x = in_sample, y = in_bag)) + -->
<!--     geom_jitter(alpha = 0.5) + -->
<!--     labs(title = "Black and White Marbles", -->
<!--          subtitle = "More white marbles in bag mean more white marbles selected", -->
<!--          x = "White Marbles Selected", -->
<!--          y = "White Marbles in the Bag") + -->
<!--     scale_y_continuous(breaks = c(0, 1, 2)) + -->
<!--   theme_classic() -->
<!-- ``` -->

<!-- ```{r} -->
<!-- joint_p -->
<!-- ``` -->

<!-- ###  -->

<!-- Awesome. We can now see the number of simulations in each "bucket." Take note that this distribution is normalized. -->

<!-- ###  -->

<!-- Let's create the following *unnormalized conditional distribution*. This is essentially a slice of the joint distribution we previously created.  -->

<!-- ```{r} -->
<!-- unnorm_p <- tibble(in_bag = rep(c(0, 1, 2), 1000)) |> -->
<!--   mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1,  -->
<!--                                               size = 3,  -->
<!--                                               p = ./2))) |>  -->
<!--   filter(in_sample == 3) |>  -->
<!--   ggplot(aes(in_bag)) + -->
<!--     geom_histogram(binwidth = 0.25, color = "white") + -->
<!--     labs(title = "Unnormalized Conditional Distribution", -->
<!--          subtitle = "Number of white marbles in bag given that three were selected in the sample", -->
<!--          x = "Number of White Marbles in the Bag", -->
<!--          y = "Count") + -->
<!--     scale_x_continuous(breaks = seq(1, 2)) + -->
<!--     theme_classic() -->

<!-- unnorm_p -->
<!-- ``` -->

<!-- ### Exercise 9 -->

<!-- Copy down every part of the empirical distribution before `ggplot()` and then use `filter()` for where `in_sample` is equal to 3. -->

<!-- ```{r three-models-9, exercise = TRUE} -->

<!-- ``` -->

<!-- ```{r three-models-9-hint-1, eval = FALSE} -->
<!-- ...|>  -->
<!--   filter(in_sample == ...) -->
<!-- ``` -->

<!-- ```{r three-models-9-test, include = FALSE} -->
<!-- tibble(in_bag = rep(c(0, 1, 2), 1000)) |> -->
<!--   mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1,  -->
<!--                                               size = 3,  -->
<!--                                               p = ./2))) |> -->
<!--   filter(in_sample == 3) -->
<!-- ``` -->

<!-- ### Exercise 10 -->

<!-- Pipe your code above to `ggplot()`. Map `in_bag` to the x-axis. Also add the layer `geom_histogram()`. -->

<!-- ```{r three-models-10, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r three-models-10-hint-1, eval = FALSE} -->
<!-- ... |>  -->
<!--   ggplot(aes(...)) + -->
<!--   geom_histogram() -->
<!-- ``` -->

<!-- ```{r three-models-10-test, include = FALSE} -->
<!-- tibble(in_bag = rep(c(0, 1, 2), 1000)) |> -->
<!--   mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1,  -->
<!--                                               size = 3,  -->
<!--                                               p = ./2))) |> -->
<!--   filter(in_sample == 3) |>  -->
<!--   ggplot(aes(x = in_bag)) + -->
<!--   geom_histogram() -->
<!-- ``` -->

<!-- ### Exercise 11 -->

<!-- Set `binwidth` to .25 and `color` to "white" within `geom_histogram()`. -->

<!-- ```{r three-models-11, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r three-models-11-hint-1, eval = FALSE} -->
<!-- ... + -->
<!--   geom_histogram(..., ...) -->
<!-- ``` -->

<!-- ```{r three-models-11-test, include = FALSE} -->
<!-- tibble(in_bag = rep(c(0, 1, 2), 1000)) |> -->
<!--   mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1,  -->
<!--                                               size = 3,  -->
<!--                                               p = ./2))) |> -->
<!--   filter(in_sample == 3) |>  -->
<!--   ggplot(aes(x = in_bag)) + -->
<!--   geom_histogram(binwidth = 0.25, -->
<!--                  color = "white") -->
<!-- ``` -->

<!-- ### Exercise 12 -->

<!-- Now use `scale_x_continuous()`. Set `breaks` to `seq()` that contains the values 1 and 2. -->

<!-- ```{r three-models-12, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r three-models-12-hint-1, eval = FALSE} -->
<!-- ... + -->
<!--   scale_x_continuous(... = seq(..., ...)) -->
<!-- ``` -->

<!-- ```{r three-models-12-test, include = FALSE} -->
<!-- tibble(in_bag = rep(c(0, 1, 2), 1000)) |> -->
<!--   mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1,  -->
<!--                                               size = 3,  -->
<!--                                               p = ./2))) |> -->
<!--   filter(in_sample == 3) |>  -->
<!--   ggplot(aes(x = in_bag)) + -->
<!--   geom_histogram(binwidth = 0.25, -->
<!--                  color = "white") +  -->
<!--   scale_x_continuous(breaks = seq(1, 2)) -->
<!-- ``` -->

<!-- ### Exercise 13 -->

<!-- Finally, use `labs()` to add the appropriate title, subtitle, and axis labels. Also add the layer `theme_classic()`. -->

<!-- ```{r three-models-13, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r three-models-13-test, include = FALSE} -->

<!-- ``` -->

<!-- Reminder: This is what your plot should look like. -->

<!-- ```{r} -->
<!-- unnorm_p -->
<!-- ``` -->

<!-- ###  -->

<!-- Let's create the following *normalized conditional distribution*. In other words, we are normalizing the graph we just created. -->

<!-- ```{r} -->
<!-- norm_p <- tibble(in_bag = rep(c(0, 1, 2), 1000)) |> -->
<!--   mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1,  -->
<!--                                               size = 3,  -->
<!--                                               p = ./2))) |>  -->
<!--   filter(in_sample == 3) |>  -->
<!--   ggplot(aes(in_bag)) + -->
<!--     geom_histogram(aes(y = after_stat(count/sum(count))),  -->
<!--                    binwidth = 0.25,  -->
<!--                    color = "white") + -->
<!--     labs(title = "Posterior Probability Distribution", -->
<!--          subtitle = "Number of white marbles in bag given that three were selected in the sample", -->
<!--          x = "Number of White Marbles in the Bag", -->
<!--          y = "Probability") + -->
<!--     scale_x_continuous(breaks = c(1, 2)) + -->
<!--     scale_y_continuous(labels =  -->
<!--                          scales::percent_format(accuracy = 1)) + -->
<!--     theme_classic() -->

<!-- norm_p -->
<!-- ``` -->

<!-- ### Exercise 14 -->

<!-- We begin our code the same way we began our code for the *unnormalized conditional distribution*. We have provided the code for you below. To begin, within `aes()` use `after_stat()` with the argument `y = count/sum(count)` to put percents on the y-axis. -->


<!-- ```{r three-models-14, exercise = TRUE} -->
<!-- tibble(in_bag = rep(c(0, 1, 2), 1000)) |> -->
<!--   mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1,  -->
<!--                                               size = 3,  -->
<!--                                               p = ./2))) |>  -->
<!--   filter(in_sample == 3) |>  -->
<!--   ggplot(aes(in_bag)) + -->
<!--     geom_histogram(binwidth = 0.25, color = "white") -->
<!-- ``` -->

<!-- ```{r three-models-14-hint-1, eval = FALSE} -->
<!-- ... + -->
<!--   geom_histogram(binwidth = 0.25, color = "white",aes(y = after_stat(count/sum(count))) -->
<!-- ``` -->

<!-- ### Exercise 15 -->

<!-- Now use `scale_x_continuous()` so the x-axis has `breaks` at 1 and 2. -->

<!-- ```{r three-models-15, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r three-models-15-hint-1, eval = FALSE} -->
<!-- Use the c() function for specifying the breaks and labels. -->
<!-- ``` -->

<!-- ```{r three-models-15-hint-2, eval = FALSE} -->
<!-- ... +  -->
<!--   scale_x_continuous(breaks = c(..., ...)) -->
<!-- ``` -->

<!-- ### Exercise 16 -->

<!-- Now use `scale_y_continuous()` to put the y-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1. -->

<!-- ```{r three-models-16, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r three-models-16-hint-1, eval = FALSE} -->
<!-- ... +  -->
<!--   scale_y_continuous(labels = scales::percent_format(...)) -->
<!-- ``` -->

<!-- ### Exercise 17 -->

<!-- Finally, use `labs()` to add the appropriate title, subtitle, and axis labels. Also add the layer `theme_classic()`. -->

<!-- ```{r three-models-17-test, exercise = TRUE} -->
<!-- tibble(in_bag = rep(c(0, 1, 2), 1000)) |> -->
<!--   mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1,  -->
<!--                                               size = 3,  -->
<!--                                               p = ./2))) |>  -->
<!--   filter(in_sample == 3) |>  -->
<!--   ggplot(aes(in_bag)) + -->
<!--     geom_histogram(binwidth = 0.25, color = "white") + -->
<!--     labs(title = "Unnormalized Conditional Distribution", -->
<!--          subtitle = "Number of white marbles in bag given that three were selected in the sample", -->
<!--          x = "Number of White Marbles in the Bag", -->
<!--          y = "Count") + -->
<!--     scale_x_continuous(breaks = seq(1, 2)) + -->
<!--     theme_classic() -->
<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- Reminder: This is what your plot should look like. -->

<!-- ```{r} -->
<!-- norm_p -->
<!-- ``` -->

<!-- ## N models  -->
<!-- ###  -->

<!-- Let's create the following *empirical distribution* for possible simulations for $\rho_h$. In other words, we will create a joint distribution of models which might be true and of data which our experiment might generate.  -->

<!-- ```{r} -->
<!-- emp_p <- tibble(p = rep(seq(0, 1, 0.1), 1000)) |> -->
<!--   mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) |> -->
<!--   ggplot(aes(y = p, x = heads)) + -->
<!--     geom_jitter(alpha = 0.1) + -->
<!--     labs(title = "Empirical Distribution of Number of Heads", -->
<!--          subtitle = expression(paste("Based on simulations with various values of ", rho[h])), -->
<!--          x = "Number of Heads out of 20 Tosses", -->
<!--          y = expression(rho[h])) + -->
<!--   scale_y_continuous(breaks = seq(0, 1, 0.1)) + -->
<!--   theme_classic() -->

<!-- emp_p -->
<!-- ``` -->

<!-- ### Exercise 1 -->

<!-- Use `tibble()` with one variable `p` set to the function `rep()`. Within `rep()` use the argument `seq()` that takes on the values 0, 1, and .1. -->

<!-- ```{r n-models-1, exercise = TRUE} -->

<!-- ``` -->

<!-- ```{r n-models-1-hint-1, eval = FALSE} -->
<!-- tibble(... = rep(seq(..., ..., ...))) -->
<!-- ``` -->

<!-- ```{r n-models-1-test, include = FALSE} -->
<!-- tibble(p = rep(seq(0, 1, 0.1))) -->
<!-- ``` -->

<!-- ###  -->

<!-- `seq()` generate regular sequences. `seq.int()` is a primitive which can be much faster but has a few restrictions. `seq_along()` and `seq_len()` are very fast primitives for two common cases. -->

<!-- ### Exercise 2 -->

<!-- Great. Let's have our code run 1000 times. Add the argument 1000 to `rep()` -->

<!-- ```{r n-models-2, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r n-models-2-hint-1, eval = FALSE} -->
<!--  tibble(p = rep(c(0, 1, .1), ...)) -->
<!-- ``` -->

<!-- ```{r n-models-2-test, include = FALSE} -->
<!-- tibble(p = rep(c(0, 1, .1), 1000)) -->
<!-- ``` -->

<!-- ### Exercise 3 -->

<!-- Pipe your code to the function `mutate()` to create the variable `heads`. Set `heads` to the function `map_int()`. The first argument to `map_int()` should be `p`. The second argument should be an `rbinom()` where `n` is set to 1, `size` is set to 20, and `p` is set to `.`. -->

<!-- ```{r n-models-3, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r n-models-3-hint-1, eval = FALSE} -->
<!--  ... |>  -->
<!--   mutate(heads = map_int(..., ~ rbinom(..., -->
<!--                                    ...,  -->
<!--                                    ...))) -->
<!-- ``` -->

<!-- ```{r n-models-3-test, include = FALSE} -->
<!-- tibble(p = rep(c(0, 1, .1), 1000)) |> -->
<!--   mutate(heads = map_int(p, ~ rbinom(n = 1, -->
<!--                                      size = 20,  -->
<!--                                      p = .))) -->
<!-- ``` -->

<!-- ###  -->

<!-- This `.` means that we are carrying the data source which is `p` and applied it as the probability of our `rbinom()` function. -->

<!-- ### Exercise 4 -->

<!-- Continue your pipe to `ggplot()`. Map `heads` to the x-axis and `p` to the y-axis. Also add the layer `geom_jitter()`.  -->

<!-- ```{r n-models-4, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r n-models-4-hint-1, eval = FALSE} -->
<!-- ... |> -->
<!--   ggplot(aes(x = ..., y = ...)) + -->
<!--     geom_jitter() -->
<!-- ``` -->

<!-- ```{r n-models-4-test, include = FALSE} -->
<!-- tibble(p = rep(c(0, 1, .1), 1000)) |> -->
<!--   mutate(heads = map_int(p, ~ rbinom(n = 1, -->
<!--                                      size = 20,  -->
<!--                                      p = .)))|> -->
<!--   ggplot(aes(x = heads, y = p)) + -->
<!--     geom_jitter() -->
<!-- ``` -->

<!-- ###  -->

<!-- `geom_jitter()` is a convenient shortcut for `geom_point(position = "jitter")`. It adds a small amount of random variation to the location of each point, and is a useful way of handling over-plotting caused by discreteness in smaller datasets. -->

<!-- ### Exercise 5 -->

<!-- Set `alpha` to .1 within `geom_jitter()`.  -->

<!-- ```{r n-models-5, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r n-models-5-hint-1, eval = FALSE} -->
<!-- ... + -->
<!--   geom_jitter(...) -->
<!-- ``` -->

<!-- ```{r n-models-5-test, include = FALSE} -->
<!-- tibble(p = rep(c(0, 1, .1), 1000)) |> -->
<!--   mutate(heads = map_int(p, ~ rbinom(n = 1, -->
<!--                                      size = 20,  -->
<!--                                      p = .)))|> -->
<!--   ggplot(aes(x = heads, y = p)) + -->
<!--     geom_jitter(alpha = 0.1) -->
<!-- ``` -->

<!-- ### Exercise 6 -->

<!-- Now use `scale_y_continuous()`. Set `breaks` to the function `seq()` that contains the values 0, 1, and .1. -->

<!-- ```{r n-models-6, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r n-models-6-hint-1, eval = FALSE} -->
<!-- ... +  -->
<!--   scale_y_continuous(breaks = seq(..., ..., ...)) -->
<!-- ``` -->

<!-- ```{r n-models-6-test, include = FALSE} -->
<!-- tibble(p = rep(c(0, 1, .1), 1000)) |> -->
<!--   mutate(heads = map_int(p, ~ rbinom(n = 1, -->
<!--                                      size = 20,  -->
<!--                                      p = .)))|> -->
<!--   ggplot(aes(x = heads, y = p)) + -->
<!--     geom_jitter(alpha = 0.1) +  -->
<!--   scale_y_continuous(breaks = seq(0, 1, 0.1)) -->
<!-- ``` -->

<!-- ### Exercise 7 -->

<!-- Finally, use `labs()` to add the appropriate title, subtitle, and axis labels. Also add the layer `theme_classic()`. You can set the y-axis label by using `y = expression(rho[h]))` -->

<!-- ```{r n-models-7, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r n-models-7-test, include = FALSE} -->
<!-- tibble(p = rep(seq(0, 1, 0.1), 1000)) |> -->
<!--   mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) |> -->
<!--   ggplot(aes(y = p, x = heads)) + -->
<!--     geom_jitter(alpha = 0.1) + -->
<!--     labs(title = "Empirical Distribution of Number of Heads", -->
<!--          subtitle = expression(paste("Based on simulations with various values of ", rho[h])), -->
<!--          x = "Number of Heads out of 20 Tosses", -->
<!--          y = expression(rho[h])) + -->
<!--   scale_y_continuous(breaks = seq(0, 1, 0.1)) + -->
<!--   theme_classic() -->
<!-- ``` -->

<!-- Reminder: This is what your plot should look like. -->

<!-- ```{r} -->
<!-- emp_p -->
<!-- ``` -->

<!-- ###  -->

<!-- Let's create the following *unnormalized conditional distribution*. This is essentially a slice of the joint distribution we previously created.  -->

<!-- ```{r} -->
<!-- unnorm_p <- tibble(p = rep(seq(0, 1, 0.1), 1000)) |> -->
<!--   mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) |>  -->
<!--   filter(heads == 8) |>  -->
<!--   ggplot(aes(p)) + -->
<!--     geom_bar() + -->
<!--     labs(title = expression(paste("Values of ", rho[h], " Associated with 8 Heads")), -->
<!--          x = expression(paste("Assumed value of ", rho[h], " in simulation")), -->
<!--          y = "Count") + -->
<!--   theme_classic() -->

<!-- unnorm_p -->
<!-- ``` -->

<!-- ### Exercise 8 -->

<!-- Copy the code from exercise 7 upto ggplot. Pipe this to `filter()` for where `heads` is equal to 8. -->

<!-- ```{r n-models-8, exercise = TRUE} -->

<!-- ``` -->

<!-- ```{r n-models-8-hint-1, eval = FALSE} -->
<!-- ... |> -->
<!--   filter(heads == ...) -->
<!-- ``` -->

<!-- ```{r n-models-8-test, include = FALSE} -->
<!-- tibble(p = rep(seq(0, 1, 0.1), 1000)) |> -->
<!--   mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) |> -->
<!--   filter(heads == 8) -->
<!-- ``` -->

<!-- ### Exercise 9 -->

<!-- Pipe your code above to `ggplot()`. Map `p` to the x-axis.  Also add the layer `geom_bar()`. -->

<!-- ```{r n-models-9, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r n-models-9-hint-1, eval = FALSE} -->
<!-- ... |>  -->
<!--   ggplot(aes(...)) + -->
<!--   geom_bar() -->
<!-- ``` -->

<!-- ```{r n-models-9-test, include = FALSE} -->
<!-- tibble(p = rep(seq(0, 1, 0.1), 1000)) |> -->
<!--   mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) |> -->
<!--   filter(heads == 8) |>  -->
<!--   ggplot(aes(x = p)) + -->
<!--     geom_bar() -->
<!-- ``` -->

<!-- ### Exercise 10 -->

<!-- Finally, use `labs()` to add the title "Values of rho[h] with 8 Heads". Then label your x-axis "Assumed value of rho[h] in simulation". Also add the layer `theme_classic()`. Use 'rho[h]' in your titles.  -->

<!-- ```{r n-models-10, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r n-models-10-test, include = FALSE} -->
<!-- tibble(p = rep(seq(0, 1, 0.1), 1000)) |> -->
<!--   mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) |>  -->
<!--   filter(heads == 8) |>  -->
<!--   ggplot(aes(p)) + -->
<!--     geom_bar() + -->
<!--     labs(title = expression(paste("Values of ", rho[h], " Associated with 8 Heads")), -->
<!--          x = expression(paste("Assumed value of ", rho[h], " in simulation")), -->
<!--          y = "Count") + -->
<!--   theme_classic() -->
<!-- ``` -->

<!-- Reminder: This is what your plot should look like. -->

<!-- ```{r} -->
<!-- unnorm_p -->
<!-- ``` -->

<!-- ###  -->

<!-- Let's create the following *normalized conditional distribution*. In other words, we are normalizing the graph we just created. -->

<!-- ```{r} -->
<!-- norm_p <-tibble(p = rep(seq(0, 1, 0.1), 1000)) |> -->
<!--   mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) |>  -->
<!--   filter(heads == 8) |>  -->
<!--   ggplot(aes(x = p)) + -->
<!--     geom_histogram(aes(y = after_stat(count/sum(count))), -->
<!--                    bins = 50) +  -->
<!--     labs(title = expression(paste("Posterior Probability Distribution of ", rho[h])), -->
<!--          x = expression(paste("Possible values for ", rho[h])), -->
<!--          y = "Probability") + -->
<!--     scale_x_continuous(breaks = seq(0.2, 0.7, by = 0.1)) + -->
<!--     scale_y_continuous(labels =  -->
<!--                         scales::percent_format(accuracy = 1)) + -->
<!--   theme_classic() -->

<!-- norm_p -->

<!-- ``` -->

<!-- ### Exercise 11 -->

<!-- We begin our code the same way we began our code for the *unnormalized conditional distribution*. We have provided the code for you below. To begin, add the layer `geom_histogram()` and set `bins` to 50. -->

<!-- ```{r n-models-11, exercise = TRUE} -->
<!--  tibble(p = rep(seq(0, 1, 0.1), 1000)) |> -->
<!--   mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) |>  -->
<!--   filter(heads == 8) |>  -->
<!--   ggplot(aes(x = p)) -->
<!-- ``` -->

<!-- ```{r n-models-11-hint-1, eval = FALSE} -->
<!-- ... + -->
<!--   geom_histogram(...) -->
<!-- ``` -->

<!-- ```{r n-models-11-test, include = FALSE} -->
<!-- tibble(p = rep(seq(0, 1, 0.1), 1000)) |> -->
<!--   mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) |>  -->
<!--   filter(heads == 8) |>  -->
<!--   ggplot(aes(x = p)) + -->
<!--   geom_histogram(bins = 50) -->

<!-- ``` -->

<!-- ### Exercise 12 -->

<!-- Within `geom_histogram()`, inside `aes()` add the argument `y = after_stat(count/sum(count))` to put percents on the y-axis. -->

<!-- ```{r n-models-12, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r n-models-12-hint-1, eval = FALSE} -->
<!-- ... + -->
<!--   geom_histogram(..., -->
<!--                  aes(y = after_stat(...)) -->
<!-- ``` -->

<!-- ```{r n-models-12-test, include = FALSE} -->
<!-- tibble(p = rep(seq(0, 1, 0.1), 1000)) |> -->
<!--   mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) |>  -->
<!--   filter(heads == 8) |>  -->
<!--   ggplot(aes(x = p)) + -->
<!--   geom_histogram(bins = 50, -->
<!--                  aes(y = after_stat(count/sum(count)))) -->

<!-- ``` -->

<!-- ### Exercise 13 -->

<!-- Now use `scale_x_continuous()`. Set `breaks` to `seq()` that contains the values 0.2 and 0.7. Also set `by` to 0.1 within `seq()`. -->

<!-- ```{r n-models-13, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r n-models-13-hint-1, eval = FALSE} -->
<!-- ... + -->
<!--   scale_x_continuous(... = seq(..., ..., breaks = ...)) -->
<!-- ``` -->

<!-- ```{r n-models-13-test, include = FALSE} -->
<!-- tibble(p = rep(seq(0, 1, 0.1), 1000)) |> -->
<!--   mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) |>  -->
<!--   filter(heads == 8) |>  -->
<!--   ggplot(aes(x = p)) + -->
<!--   geom_histogram(bins = 50, -->
<!--                  aes(y = after_stat(count/sum(count)))) + -->
<!--   scale_x_continuous(breaks = seq(0.2, 0.7, breaks = 0.1)) -->
<!-- ``` -->

<!-- ### Exercise 14 -->

<!-- Now use `scale_y_continuous()` to put the y-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1. -->

<!-- ```{r n-models-14, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r n-models-14-hint-1, eval = FALSE} -->
<!-- ... +  -->
<!--   scale_y_continuous(labels = scales::percent_format(...)) -->
<!-- ``` -->

<!-- ```{r n-models-14-test, include = FALSE} -->
<!-- tibble(p = rep(seq(0, 1, 0.1), 1000)) |> -->
<!--   mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) |>  -->
<!--   filter(heads == 8) |>  -->
<!--   ggplot(aes(x = p)) + -->
<!--   geom_histogram(bins = 50, -->
<!--                  aes(y = after_stat(count/sum(count)))) + -->
<!--   scale_x_continuous(breaks = seq(0.2, 0.7, breaks = 0.1))  +  -->
<!--   scale_y_continuous(labels = scales::percent_format(accuracy = 1)) -->
<!-- ``` -->

<!-- ### Exercise 15 -->

<!-- Finally, use `labs()` to add the title "Posterior Probability Distribution of rho[h]". Then label your x-axis "Possibility values for rho[h]" and y-axis "Probability". Also add the layer `theme_classic()`. -->

<!-- ```{r n-models-15, exercise = TRUE} -->

<!-- ``` -->

<!-- <button onclick = "transfer_code(this)">Copy previous code</button> -->

<!-- ```{r n-models-15-test, include = FALSE} -->
<!-- tibble(p = rep(seq(0, 1, 0.1), 1000)) |> -->
<!--   mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) |>  -->
<!--   filter(heads == 8) |>  -->
<!--   ggplot(aes(x = p)) + -->
<!--     geom_histogram(aes(y = after_stat(count/sum(count))), -->
<!--                    bins = 50) +  -->
<!--     labs(title = expression(paste("Posterior Probability Distribution of ", rho[h])), -->
<!--          x = expression(paste("Possible values for ", rho[h])), -->
<!--          y = "Probability") + -->
<!--     scale_x_continuous(breaks = seq(0.2, 0.7, by = 0.1)) + -->
<!--     scale_y_continuous(labels =  -->
<!--                         scales::percent_format(accuracy = 1)) + -->
<!--   theme_classic() -->

<!-- ``` -->

<!-- Reminder: This is what your plot should look like. -->

<!-- ```{r} -->
<!-- norm_p -->
<!-- ``` -->

## PDs with `rbinom()`
### 

Consider *binomial distribution*, the case in which the probability of some Boolean variable (for instance success or failure) is calculated for repeated, independent trials. One common example would be the probability of flipping a coin and landing on heads.

### 

### Exercise 1

Create a tibble and within set `heads` to `rbinom()`.

```{r pds-with-rbinom-1, exercise = TRUE}

```

```{r pds-with-rbinom-1-hint-1, eval = FALSE}
tibble(heads = ...())
```

```{r pds-with-rbinom-1-test, include = FALSE}
# tibble(heads = rbinom())
```

Note: you will get an error, we will fix this in the next exercise.

### 

The function `rbinom()` allows us to draw from a binomial distribution. This function takes three arguments, `n`, `size`, and `prob`.

### Exercise 2

Within `rbinom()` set `n` to `10000`, `size` to `10`, and `prob` to `0.5`.

```{r pds-with-rbinom-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pds-with-rbinom-2-hint-1, eval = FALSE}
...(... = rbinom(n = ..., ... = 10, prob = ...))
```

```{r pds-with-rbinom-2-test, include = FALSE}
tibble(heads = rbinom(n = 10000, size = 10, prob = 0.5))
```

### 

`n` is the number of values we seek to draw. `size` is the number of trials for each n. `prob` is the probability of success on each trial.

### Exercise 3

Start a pipe with the above code with `ggplot()` and set `x` to `heads` in `aes()`.

```{r pds-with-rbinom-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pds-with-rbinom-3-hint-1, eval = FALSE}
... |>
  ggplot(...(x = ...))
```

```{r pds-with-rbinom-3-test, include = FALSE}
tibble(heads = rbinom(n = 10000, size = 10, prob = 0.5)) |>
  ggplot(aes(x = heads))
```

### Exercise 4

Add `geom_bar()` after the `ggplot()`.

```{r pds-with-rbinom-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pds-with-rbinom-4-hint-1, eval = FALSE}
... + 
  geom_bar()
```

```{r pds-with-rbinom-4-test, include = FALSE}
tibble(heads = rbinom(n = 10000, size = 10, prob = 0.5)) |>
  ggplot(aes(x = heads)) + 
  geom_bar()
```

### Exercise 5

Let's add `labs()` to the graph. Set `title` to `"Flipping a Fair Coin 10 Times"`, set `subtitle` to `"Extreme results are possible with enough experiments"`, `x` to `"Result"`, and `y` to `"Count"`.

```{r pds-with-rbinom-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pds-with-rbinom-5-test, include = FALSE}
tibble(heads = rbinom(n = 10000, size = 10, prob = 0.5)) |>
  ggplot(aes(x = heads)) + 
  geom_bar() +
  labs(title = "Flipping a Fair Coin 10 Times",
       subtitle = "Extreme results are possible with enough experiments",
       x = "Result",
       y = "Count")
```

### 

Randomness creates (inevitable) tension between distribution as a â€œthingâ€ and distribution as a vector of draws from that thing. In this case, the vector of draws is not balanced between Tails and Heads. Yet, we â€œknowâ€ that it should be since the coin is, by definition, fair. In a sense, the mathematics require an even split. Yet, randomness means that the vector of draws will rarely match the mathematically â€œtrueâ€ result.

### Exercise 6

Add `scale_x_continuous()` with `breaks` set to `c(0, 1)` and `labels` set to `c("Tails", "Heads")`.

```{r pds-with-rbinom-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pds-with-rbinom-6-hint-1, eval = FALSE}
... +
  scales_x_continuous(breaks = ...,
                      labels = ...)
```

```{r pds-with-rbinom-6-test, include = FALSE}
tibble(heads = rbinom(n = 10000, size = 10, prob = 0.5)) |>
  ggplot(aes(x = heads)) + 
  geom_bar() +
  labs(title = "Flipping a Fair Coin 10 Times",
       subtitle = "Extreme results are possible with enough experiments",
       x = "Result",
       y = "Count") + 
  scale_x_continuous(breaks = c(0, 1), 
                     labels = c("Tails", "Heads"))
```

### 

In our graph above, we use the function `scale_x_continuous()` because our x-axis variable is continuous, meaning it can take on any real values. The `breaks` argument to `scale_x_continuous()` converts our x-axis to having two different â€œtick marksâ€. There is a fairly even distribution of Tails and Heads. More draws would typically result in an even more equal split.

### Exercise 7

Copy the code from above and change `prob` to `0.75` within `rbinom()`.

```{r pds-with-rbinom-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pds-with-rbinom-7-hint-1, eval = FALSE}
tibble(heads = rbinom(n = 10000, size = 10, prob = ...))
```

```{r pds-with-rbinom-7-test, include = FALSE}
tibble(heads = rbinom(n = 10000, size = 10, prob = 0.75)) |>
  ggplot(aes(x = heads)) + 
  geom_bar() +
  labs(title = "Flipping a Fair Coin 10 Times",
       subtitle = "Extreme results are possible with enough experiments",
       x = "Result",
       y = "Count") + 
  scale_x_continuous(breaks = c(0, 1), 
                     labels = c("Tails", "Heads"))
```

### 

Here we can simulate an unfair coin, where the probability of landing on Heads was 0.75 instead of 0.25.

### Exercise 8

Copy the code from above and change the `scale_x_continuous()` to only include `breaks` which is set to `c(0,10)`.

```{r pds-with-rbinom-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r pds-with-rbinom-8-hint-1, eval = FALSE}
... +
    scale_x_continuous(breaks = 0:10)
```

```{r pds-with-rbinom-8-test, include = FALSE}
tibble(heads = rbinom(n = 10000, size = 10, prob = 0.75)) |>
  ggplot(aes(x = heads)) + 
  geom_bar() +
  labs(title = "Flipping a Fair Coin 10 Times",
       subtitle = "Extreme results are possible with enough experiments",
       x = "Result",
       y = "Count") + 
  scale_x_continuous(breaks = c(0, 10), 
                     labels = c("Tails", "Heads"))
```

### 

Here we have a situation in which we are 10,000 times, flipping a unfair coin 10 times. We can see that "Heads" was favored the most throughout the entire flipping. Check out [**binomial distribution**] https://stat.ethz.ch/R-manual/R-devel/library/stats/html/Binomial.html to learn more about the data involved with binomial distribution.

<!-- DK: Make everything below much more like the tempate_tutorial. -->

## Wisdom
*All we can know is that we know nothing. And thatâ€™s the height of human wisdom.* - Leo Tolstoy

### 

*Wisdom* starts by creating the Preceptor Table. What data, if we had it, would allow us to answer our question easily? If the Preceptor Table has one outcome, then the model is predictive. If it has more than one (potential) outcome, then the model is causal. 


### Exercise 1

In your own words, describe the key components of Wisdom for working on a data science problem.

```{r wisdom-1}
question_text(NULL,
	message = "Wisdom requires the creation of a Preceptor Table, an examination of our data, and a determination, using the concept of validity, as to whether or not we can (reasonably!) assume that the two come from the same population.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 2

Define a Preceptor Table.

```{r wisdom-2}
question_text(NULL,
	message = "A Preceptor Table is the smallest possible table of data with rows and columns such that, if there is no missing data, it is easy to calculate the quantities of interest.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

One key aspect of a Preceptor Table is whether or not we need more than one potential outcome in order to calculate our estimand. For example, if we want to know the causal effect of exposure to Spanish-speakers on attitude toward immigration then we need a causal model, one which estimates that attitude for each person under both treatment and control. 

### Exercise 3

Describe the key components of Preceptor Tables in general. Use words like "units," "outcomes," and "covariates."

```{r wisdom-3}
question_text(NULL,
	message = "The rows of the Preceptor Table are the units. The outcome is at least one of the columns. If the problem is causal, there will be at least two (potential) outcome columns. The other columns are covariates. If the problem is causal, at least one of the covariates will be a treatment.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 4

<!-- need to include units/time -->

Write two sentences explaining a predictive model in your life. Include the one outcome variable of interest. 

```{r wisdom-4}
question_text(NULL,
	message = "A predictive model in my life can be seen as the money that I will potentially spend on groceries per week. I can take all of the data that I have from the previous weeks to estimate how much I will spend on groceries with a predictive model. Outcome: How much will I spend on groceries?",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

	
A predictive models has just one outcome column in its Preceptor Table.

### Exercise 5

Write two sentences explaining a causal model in your life. Include the two potential outcomes and the treatment variable. 

```{r wisdom-5}
question_text(NULL,
	message = "A causal model in my life can be seen as the money that I will spend on groceries based on whether I go to the gym to exercise. Two potential outcomes: dollars spent on groceries if I do go to the gym and dollars spent on groceries if I don't go to the gym. The treatment is going to the gym or not going to the gym. The following situation is an example of a causal model because there are two outcome columns in the Preceptor Table.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

Causal models aim to determine the effect of manipulating a specific variable on the outcome by comparing two or more potential outcomes for each unit. The difference between predictive models and causal models is that the former has one column for the outcome variable in the Preceptor Table and the latter has more than one column.

### Exercise 6

Scenario: You are an analyst at the mayor's office and want to find out what it will take for people to be more kind towards immigrants. You have previous data regarding individuals who were exposed to one of two possible conditions, and then their attitudes towards immigrants were recorded. One condition was waiting on a train platform near individuals speaking Spanish. The other was being on a train platform without Spanish-speakers. You are going to use this data and conduct your own analysis. You will give speeches on citizens through random assignment that includes a positive message regarding immigrants. Your hope is that the causal effect of those speeches is to make people be kinder. 

### 

Is this scenario a predictive model or a causal model? Explain why in two sentences.

```{r wisdom-6}
question_text(NULL,
	message = "This scenario is a causal model because there are multiple potential outcomes in the Preceptor Table. Causal models have more than one potential outcome while predictive models only have one outcome.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### Exercise 7

Let's create a Preceptor Table by finding each column needed from the scenario. Write two sentences about what the rows are of the situation and how it relates to the scenario.

```{r wisdom-7}
question_text(NULL,
	message = "We are going to use three rows: Citizens, Treatments, and Potential Outcomes. We are concerned about each citizen and the data that each one of them will contain.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### Exercise 8

What is the treatments for this problem?

```{r wisdom-8}
question_text(NULL,
	message = "Which citizens have heard the speech?",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

### Exercise 9

Write two sentences about what the *potential outcomes* are of the situation and how it relates to the scenario. Remember this is a causal model which means that there will be multiple potential outcomes. 

```{r wisdom-9}
question_text(NULL,
	message = "Potential Outcomes: 
	           1. People who heard the speech and changed to be kind
	           2. People who heard the speech and changed to be not kind              3. People who didn't hear the speech and are kind
	           4. People who didn't hear the speech are not kind
	           These are the four potential outcomes at hand because of              the influence from the treatment that will change the                 outcome of the scenario.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### Exercise 10

In your own words, define "validity" as we use the term.

```{r wisdom-10}
question_text(NULL,
	message = "Validity is the consistency, or lack thereof, in the columns of the data set and the corresponding columns in the Preceptor Table.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

In order to consider the two datasets to be drawn from the same population, the columns from one must be have a valid correspondence with the columns in the other. 

### Exercise 11

Provide a reason why the *assumption of validity* might not hold with the data from immigrants with Spanish-speakers on the train to our scenario of giving citizens a speech to be more kind. Explain how that failure might impact the results.

```{r wisdom-11}
question_text(NULL,
	message = "The treatment in the data (Spanish speakers on a train platform) and the treatment in the Preceptor Table (a speech from the mayor about immigrants) are not similar enough that we can reasonably expect them to have the same causal effects. People are often annoyed by stangers but can react very differently to an elected official.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

*Validity*, if true (or at least reasonable), allows us to construct the Population Table.

## Justice
*The arc of the moral universe is long, but it bends toward justice.* - Theodore Parker

### 

*Justice* starts with the Population Table â€“ the data we want to have, the data which we actually have, and all the other data from that same population. Each row of the Population Table is defined by a unique Unit/Time combination.

### Exercise 1

In your own words, name the four key components of Justice for working on a data science problem.

```{r justice-1}
question_text(NULL,
	message = "Justice concerns four topics: the Population Table, stability, representativeness, and unconfoundedness.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### Exercise 2

In your own words, define a Population Table.

```{r justice-2}
question_text(NULL,
	message = "The Population Table includes a row for each unit/time combination in the underlying population from which both the Preceptor Table and the data are drawn.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### Exercise 3

In your own words, define the assumption of "stability" when employed in the context of data science.

```{r justice-3}
question_text(NULL,
	message = "Stability means that the relationship between the columns in the Population Table is the same for three categories of rows: the data, the Preceptor Table, and the larger population from which both are drawn.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

Stability is all about *time*. Is the relationship among the columns in the Population Table stable over time? In particular, is the relationship --- which is another way of saying "mathematical formula" --- at the time the data was gathered the same as the relationship at the (generally later) time references by the Preceptor Table.

### Exercise 4

Scenario: You are an analyst at the mayor's office and want to find out what it will take for people to be more kind towards immigrants. You have previous data regarding individuals who were exposed to one of two possible conditions, and then their attitudes towards immigrants were recorded. One condition was waiting on a train platform near individuals speaking Spanish. The other was being on a train platform without Spanish-speakers. You are going to use this data and conduct your own analysis. You will give speeches on citizens through random assignment that includes a positive message regarding immigrants. Your hope is that the causal effect of those speeches is to make people be kinder. 

### 

Provide one reason why the assumption of stability might not be true in this case.

```{r justice-4}
question_text(NULL,
	message = "The assumption of stability might not hold because the relationship with our data (Spanish speakers on a train platform) and Preceptor Table (a speech from the mayor about immigrants) are not similar enough. ",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### Exercise 5

In your own words, define the assumption of "representativeness" when employed in the context of data science.

```{r justice-5}
question_text(NULL,
	message = "Representativeness, or the lack thereof, concerns two relationship, among the rows in the Population Table. The first is between the Preceptor Table and the other rows. The second is between our data and the other rows.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

Ideally, we would like both the Preceptor Table *and* our data to be random samples from the population. Sadly, this is almost never the case.

### Exercise 6

Provide one reason why the assumption of representativeness might not be true in this case.

```{r justice-6}
question_text(NULL,
	message = "The assumption of representatives might not be true because the sample of our data (Spanish speakers on a train platform) and Preceptor Table (a speech from the mayor about immigrants) are not random enough.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### Exercise 7

In your own words, define the assumption of "unconfoundedness" when employed in the context of data science.

```{r justice-7}
question_text(NULL,
	message = "Unconfoundedness means that the treatment assignment is independent of the potential outcomes, when we condition on pre-treatment covariates.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

This assumption is only relevant for causal models. We describe a model as "confounded" if this is not true.

### Exercise 8

In one sentence, provide a reason why the assumption of unconfoundedness would hold.

```{r justice-8}
question_text(NULL,
	message = "The assumption of unconfoundedness would hold because the sample of our data (Spanish speakers on a train platform) and Preceptor Table (a speech from the mayor about immigrants) are part of a causal model and we are randomly assigning treatment to the citizens.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

Unconfoundedness is related to the absence of confounding variables that may bias the relationship between the outcome variable and covariates. It implies that there are no hidden factors influencing both the treatment (if applicable) and the outcome.


## Courage
*Courage is the commitment to begin without any guarantee of success.* - Johann Wolfgang von Goethe

### 

*Courage* allows us to explore different models. Even though *Justice* has provided the basic mathematical structure of the model, we still need to decide which variables to include and to estimate the values of unknown parameters. 

### Exercise 1

What is the significance of the *Posterior Probability Distributions*, explain in one sentence. 

```{r courage-1}
question_text(NULL,
	message = "With posterior probability distributions, we can compare the actual values of the outcome variable with the â€œfittedâ€ or â€œpredictedâ€ results of the model.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

Through Posterior Probability Distributions we are able to examine the â€œresiduals,â€ the difference between the fitted and actual values.

### Exercise 2

In the first sentence write the equation for outcome. In the second sentence explain why we use this equation of outcome. 

Hint: The sum of two other elements.

```{r courage-2}
question_text(NULL,
	message = "outcome = model + what is not in the model. We use the equation of outcome to view the potential outcomes that may arise with our model and the data we have not in our model.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

It doesnâ€™t matter what the outcome is. It could be the result of a coin flip, the weight of a person, the GDP of a country. Whatever outcome we are considering is always made up of two parts. The first is the model we have created. The second is all the stuff â€” all the blooming and buzzing complexity of the real world â€” which is not a part of the model.

### Exercise 3

In one sentence, explain the definition of a *Parameter* and its uses in the Preceptor Table.

```{r courage-3}
question_text(NULL,
	message = "A parameter is a mental abstraction or a building block used in statistical modeling to replace unknown values and help achieve the goal of replacing question marks in the actual Preceptor Table.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

A parameter is something which does not exist in the real world. (If it did, or could, then it would be data.) Since parameters are mental abstractions, we will always be uncertain as to their value, however much data we might collect.

## Temperance
*Temperance to be a virtue must be free, and not forced.* - Philip Massinger

### 

*Temperance* guides us in the use of the model we have created to answer the questions we began with. We create posteriors of quantities of interest. We should be modest in the claims we make. The posteriors we create are never the â€œtruth.â€

### Exercise 1

What is the definitions and difference between *Preceptor's Posterior* and *Estimated Posterior*, explain in one sentence.

```{r temperance-1}
question_text(NULL,
	message = "Preceptor's Posterior represents the perfect, unknown true distribution, while the estimated posterior is a calculated approximation of that distribution based on available data and modeling assumptions.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

### 

In Temperance, the key distinction is between the true posterior distribution â€” what we will call Preceptorâ€™s Posterior â€” and the estimated posterior distribution. Sadly, even if our estimated posterior is, very close to Preceptorâ€™s Posterior, we can never be sure of that fact, because we can never know the truth, never be certain that all the assumptions we made are correct.

### Exercise 2

What is the *Fundamental Problem of Causal Inference*? 

Hint: Look into chapter summary of [Rubin Causal Model](https://ppbds.github.io/primer/04-rubin-causal-model.html#summary)

```{r temperance-2}
question_text(NULL,
	message = "The Fundamental Problem of Causal Inference is that it is impossible to observe the causal effect on a single unit because we can never observe both potential outcomes for that unit. We must make assumptions in order to estimate causal effects.",
	answer(NULL, correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

## Summary
### 

This tutorial covered [Chapter 2: Probability](https://ppbds.github.io/primer/probability.html) of [*Preceptorâ€™s Primer for Bayesian Data Science: Using the Cardinal Virtues for Inference*](https://ppbds.github.io/primer/) by [David Kane](https://davidkane.info/).  

After finishing this tutorial you should be able to:
  1. Use `list()` ,`map()`, `map_*()`, and `tibble()` functions.
  2. Use `tibble()`, `mutate()`,`map_*()`, `rep()` and `sample()` to generate data.
  3. Know about different types of distribution.
  4. Create distributions using tools above and from earlier chapters.
  5. Understand the meaning of each distribution by looking at each graph.

```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
