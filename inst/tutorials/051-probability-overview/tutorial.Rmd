---
title: 'Probability: Overview'
author: Yuhan Wu
tutorial:
  id: probability-overview
output:
  learnr::tutorial:
    progressive: yes
    allow_skip: yes
runtime: shiny_prerendered
description: 'Questions which map to the text in Chapter 5: Probablility.'
---

```{r setup, include = FALSE}
library(learnr)
library(primer.tutorials)
library(tidyverse)
library(primer.data)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 
```

```{r copy-code-chunk, child = "../../child_documents/copy_button.Rmd"}
```

```{r info-section, child = "../../child_documents/info_section.Rmd"}
```


<!-- MAKE THIS MATCH THE NEW VERSION OF THE PRIMER. -->

<!-- Tricks to keep in mind when doing simulations in R: First, organize everything in a tibble. This makes it easy to see what is going on. Often, we will first make sure that the code is working with a small tibble with just a few rows and selected values for the key variables. Then, when that looks good, run it for real with x = 1:100 or whatever. -->

<!-- Second, build the tibble column-by-column. We will often start with an ID column whose only purpose is to set up the size of the tibble. Then, we add new columns with mutate(). Often, we add one column and then use that column as input to a map function which adds another column and then use that column to do something else. Read the examples in Chapter 6 closely. -->

<!-- Third, recall that map() returns a list, which allows you to create a list-column. This is very handy. Let's say you want to get the sum of 6 rolls from a dice. Instead of doing a roll in each row and then summing the rows --- which can work but which can also be a bother --- use something like `mutate(six_rolls = map(ID, ~  roll_die(n = 6))` to get a list of the 6 rolls. You can then manipulate six rolls, which is a list-column, in subsequent steps. -->




## Introduction

### 

This tutorials will include 5 key lessons

  1. Learn about `list()` ,`map()`, `map_*()`, and `tibble()` functions.

  2. Practice using `tibble()`, `mutate()`,`map_*()`, `rep()` and `sample()` to generate data.
  
  3. Learn about different types of distribution.
  
  4. Create distributions using tools above and from earlier chapters.
  
  5. Start thinking about the meaning of each distribution by looking at each graph.


## List-columns and map functions
### 

<!-- DK: Drop some knowledge. Some info from this link. Or share the link. Or something: -->

<!-- https://r4ds.had.co.nz/iteration.html?q=map#the-map-functions -->

<!-- https://www.rstudio.com/resources/webinars/how-to-work-with-list-columns/ -->

### Exercise 1

Use c() to combine the following numbers : 4, 16, 9

```{r listcolumns-and-map--1, exercise = TRUE}

```

```{r listcolumns-and-map--1-hint-1, eval = FALSE}
c(..., ..., ...)
```

###
`c()` combines its arguments to form a vector. 

### Exercise 2

Now use `c()` to combine two letters ("A" and "Z") into a single vector.

```{r listcolumns-and-map--2, exercise = TRUE}

```


```{r listcolumns-and-map--2-hint-1, eval = FALSE}
c(..., ...)
```

### Exercise 3

Use `list()` to create two elements the first element is the combine numbers in first exercise, the second is the combine letters in second exercise.

```{r listcolumns-and-map--3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map--3-hint-1, eval = FALSE}
list(c(...), c(...))
```

### Exercise 4

Now assign the list() we just created to an variable x, then run x[[1]], it should returns the first element which is the 3 numbers.

```{r listcolumns-and-map--4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map--4-hint-1, eval = FALSE}
x <- list(c(),c())
x[[1]]
```

### Exercise 5

Pick 10 random values in which the mean is 0 and standard deviation is 1. Recall chapter two if necessary. 

```{r listcolumns-and-map--5, exercise = TRUE}

```

```{r listcolumns-and-map--5-hint-1, eval = FALSE}
rnorm(10)
```

### 

You could do something like `rnorm(n = 10, mean = 0, sd = 1)`, but since we are using the default value of rnorm, we can simply do `rnorm(10)`.


### Exercise 6

Use the `range()` to take the range of `rnorm(10)`.

```{r listcolumns-and-map--6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map--6-hint-1, eval = FALSE}
range(rnorm(10))
```

###
`range()` returns a *vector* containing the minimum and maximum of all the given arguments.

### Exercise 7

Take the list of the range we created above using `list()`.
```{r listcolumns-and-map--7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map--7-hint-1, eval = FALSE}
list(range(rnorm(...)))
```

### Exercise 8

Now take the list we created above assign it into a tibble using `tibble()` in which the column name is `col_1`.

```{r listcolumns-and-map--8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map--8-hint-1, eval = FALSE}
tibble(col_1 = list(range(rnorm(...))))
```

### 

Now you have created a list-column which is a 1-by-1 tibble with one observation, which is a list of one element.


### Exercise 9

Pipe down your result, use `map_dbl()`to create and work with the list-column we create. Within `map_dbl()`, set the first argument to `col_1`, the second to the formula that calculate the sum of the range in col_1 using `sum()`, don't forget the `~` before formula, and the `.` within `sum()`.

```{r listcolumns-and-map--9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map--9-hint-1, eval = FALSE}
tibble(col_1 = list(range(rnorm(10)))) |> 
  mutate(col_2= map_dbl(col_1, ~sum(.)))
```

### 

We can replace the `~ sum(.)` to simply sum as an statement, but we generally working with formula more often, so we practice using `~ sum(.)` instead.

### Exercise 10

Let's try using other map_* functions, use `map_int()` to set the first argument to col_1, replace `sum()` with `length()`, and assign the `map_int()` to a new column `col_3`.

```{r listcolumns-and-map--10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map--10-hint-1, eval = FALSE}
tibble(col_1 = list(range(rnorm(10)))) |> 
  mutate(col_2= map_dbl(col_1, ~sum(.))) |>
  mutate(col_3= map_int(col_1, ~length(.)))
```

### 

Again if we replace `~ length(.)` with just `length`, we would got the same result.


### Exercise 11

Let's try using other map_* functions, use `map_chr()` set the first argument to col_1, replace `length()` with `mean()`, and assign the `map_chr()` to a new column `col_4`.
```{r listcolumns-and-map--11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map--11-hint-1, eval = FALSE}
tibble(col_1 = list(range(rnorm(10)))) |> 
  mutate(col_2= map_dbl(col_1, ~sum(.))) |>
  mutate(col_3= map_int(col_1, ~length(.)))|>
  mutate(col_4= map_chr(col_1, ~mean(.)))
```

### 

The reason for why we are doing these almost the same exercise is to show you how different map_* functions would returns different vectors for the new column we create.

### Exercise 12

Create a tibble using tibble(), set the first column ID equal to a set of integers form 1 to 10. 
```{r listcolumns-and-map--12, exercise = TRUE}

```


```{r listcolumns-and-map--12-hint-1, eval = FALSE}
tibble(ID= 1:10)
```

We can get the consecuetive integers we want by using : instead of c().

### Exercise 13

Use mutate() to create a new column called N, set n equal an value from 10 random values in which the mean is 0 and standard deviation is 1. 
```{r listcolumns-and-map--13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map--13-hint-1, eval = FALSE}
tibble(ID = 1:10) |>
  mutate(N = sample(rnorm(10),size=1))
```

### 

Note how all N is equal, essentially what happened here is N calculate it self using the sample() function and copy it 10 times to matched the ID column.

### Exercise 14

Create an new column called Y using mutate(), this time use map_dbl(), set the first argument to ID to represent the data source, the second argument to the `sample()` *Formula* we created in the last exercise.
```{r listcolumns-and-map--14, exercise = TRUE}

```

Remember for formula we always add the `~` at front. 

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r listcolumns-and-map--14-hint-1, eval = FALSE}
tibble(ID = 1:10) |>
  mutate(N = sample(rnorm(10),size=1)) |>
  mutate(Y = map_dbl(ID, ~ sample(rnorm(...),size=...)))
```

### 

When we add on the map_* () function to the mutate, it grabs the data in this case is `ID`, and it deals with each one of the data using the formula in the second statement `~sample()`, that's why we would get different results for each ID in the Y column but not in the N column.

## Distributions
###

Let's create this normal distribution by the end of this section.

```{r}
shoesize_p <- tibble(Wshoes = rnorm(n = 100000, mean = 8, sd = 1.5),
       Mshoes = rnorm(n = 100000, mean = 10.5, sd = 1.5)) |> 
  pivot_longer(cols = everything(), 
               names_to = "distribution", 
               values_to = "value") |>  
   ggplot(aes(x = value, fill = distribution)) +
    geom_histogram(aes(y = after_stat(count/sum(count))),
                   alpha = 0.5, 
                   bins = 100, 
                   position = "identity") +
    labs(title = "Normal Distributions of shoe sizes",
         x = "Value",
         y = "Probability")

shoesize_p
```

### Exercise 1

Create a `tibble`, with one variable `numbers`, and set `numbers` equal to the consecutive integers from 1 to 101 inclusive.

```{r review-1, exercise = TRUE}

```

```{r review-1-hint-1, eval = FALSE}
tibble(numbers = 1:101)
```

### 

Note that the vector of `numbers` is integers, if you try putting `c()` around the two numbers, and
replace `:` with comma, the two numbers become `double` instead.

### Exercise 2

Pipe the results and then use `summarise()`, create a new column name `avg` which is equal to the `mean()` of `numbers`.

```{r review-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r review-2-hint-1, eval = FALSE}
...|>
  summarize(avg = mean(...))
```

### 

`summarise()` does not keep any of the variables in the input tibble, unless `group_by()` is used beforehand and, even then, only the variables in `group_by()` are kept.

### Exercise 3

Within the `summarise()`, add a new argument separate by comma, `middle`, and set Median equal to the median of `numbers` using `median()`.

```{r review-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r review-3-hint-1, eval = FALSE}
tibble(numbers = 1:101) |> 
  summarise(avg = mean(numbers),
            middle = median(numbers))
```

### 

Both `mean()` and `median()` have `na.rm` value set to its default `FALSE`, the `na.rm` means the function does not consider NA value in the tibble.



### Exercise 4

Within the `summarise()`, add a new argument separate by comma, `stan_dev`, and set `stan_dev` equal to the standard deviation of `numbers` using sd().Recall standard deviation is measuring how spread out our numbers were.

```{r review-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r review-4-hint-1, eval = FALSE}
tibble(numbers = 1:101) |> 
  summarise(avg = mean(...),
            middle = median(...),
            stan_dev = sd(...))
```

###
Note that the x value inside `mean()` ,`median()` and `sd()` has to be a numeric vector, not a factor or logical. 

### Exercise 5

Within the `summarise()`, add a new argument seperated by comma, `med_dev`, and set mad equal to the median absolute deviation of `numbers` using `mad()`. 

```{r review-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r review-5-hint-1, eval = FALSE}
tibble(numbers = 1:100) |> 
  summarise(avg = mean(...),
            middle = median(...),
            stan_dev = sd(...),
            med_dev = mad(...))
```

###
`mad` stands for median absolute deviation, essentially is how spread out around the median, note that the number should be different in this case. sd is looking for the square of difference, yet mad is looking at the absolute difference.

### Exercise 6

Last but not least, within `summarise()`, add `quantile`, use `quantile()`, within set the first arugument to `numbers`, and the second is `prob` which equal to `c(0, 0.5, 1)`.

```{r review-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r review-6-hint-1, eval = FALSE}
tibble(numbers = 1:100) |> 
  summarise(Mean = mean(numbers),
            Median = median(numbers),
            sd = sd(numbers),
            mad = mad (numbers),
            quantile = quantile(numbers , prob = c(0 ,0.5, 1)))
```

### 

It will create another two rows, because quantile has three values in it's column, yet if we want to keep it in one rows, we can add `list()` around `quantile()`, so that we create an list-column for column quantile and keep everything else in 1 row.


### Exercise 7

Start a new pipe using `tibble()`, make the first column name is `ID`, and set it equal to the consecutive integer from 1 to 100, then make the second column which name is `scores`, and set it equal using rep() where value `1350` occurs 20 times, value `1380` occurs 30 times, `1440` occurs 40 times, and `1520` occurs 10 times. Remember to group the `rep()` together using `c()`.

```{r review-7, exercise = TRUE}

```


```{r review-7-hint-1, eval = FALSE}
tibble(ID = ... , scores = c(rep(1350, ...),
                             rep(1380, ...),
                             rep(1440, ...),
                             rep(1520, ...)))
```

### 
We can use `c()` to combine the `rep()` of numbers into vectors, and within `tibble()` or `mutate()` we can turn this vector into a column.

### Exercise 8

Now let's say you are a admission officer, and here is the score, now you want to look at the percentile of the score. Use the summarize function to make a new column called "percentile", set equal to `quantile()`, first argument is scores, the second is `prob`, and set it equal to (.35, .50, .75).

```{r review-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r review-8-hint-1, eval = FALSE}
tibble(ID = 1:100 , scores = c(rep(1350, ...),
                               rep(1380, ...),
                               rep(1440, ...),
                               rep(1520, ...))) |>
  summarise(percentile = quantile(scores, prob = c(.35, .50, .75)))
```

### 
Function `quantile()` produces sample quantiles corresponding to the given probabilities. The smallest observation corresponds to a probability of 0 and the largest to a probability of 1.



### Exercise 9

Now let's say instead looking at the percentile you want to randomly pick 10 people from 1350 to 1520 score range to admit.Within `summarise()`, replace `percentile` to `admit`, and set it equal using `sample()`, within `sample()`, the first argument is `scores`, second set `size` equal to 10, and third set `replace` equals `FALSE`.

```{r review-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r review-9-hint-1, eval = FALSE}
tibble(ID = 1:100 , scores = c(rep(1350, ...),
                               rep(1380, ...),
                               rep(1440, ...),
                               rep(1520, ...))) |>
  summarise( admit = sample(scores, size = ..., replace = ...))
```

### 

Within `sample()`, the first argument represents the data source, `size` means the number of values we are picking, and `replace` means whether we pick the same value twice.


### Exercise 10

Let's now use `runif()` to draw from a uniform distribution. Within `runif()`, set `n` to 5 (the number of draws), `min` to 5, and `max` to 8. 
```{r review-10, exercise = TRUE}

```


```{r review-10-hint-1, eval = FALSE}
runif(n = ..., min = ..., max =...)
```

### 

The [runif](https://www.geeksforgeeks.org/create-random-deviates-of-uniform-distribution-in-r-programming-runif-function/) function creates a random uniform distribution between your chosen minimum and maximum values.

### Exercise 11

Start a pipe with `tibble()`, set the value `heads` equals to `rbinom()`, with the first argument equal to 1000, second argument `size` equal to 1, and the third argument `prob` equal to 0.5.

```{r review-11, exercise = TRUE}

```

```{r review-11-hint-1, eval = FALSE}
tibble(heads = rbinom(n = 1000, size = 1, prob = 0.5))
```

### 

`rbinom()` is used for the scenario where there is only two possible outcome also known as Boolean data type, the coin toss in this case is an example of an Boolean data. Within `rbinom()` the value `n` means how many value is draw, `size` is how many value draws each time, and `prob` is the probability of the outcome.


### Exercise 12

We can give a quick look at what the graph looks like, pipe down the `tibble()` and add `ggplot()`, within `ggplot()`, use aes() and set `x =  heads`, then add the layer geom_bar()`.

```{r review-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r review-12-hint-1, eval = FALSE}
tibble(heads = rbinom(n = 1000, size = 1, prob = 0.5)) |>
  ggplot(aes(x = heads))+
  geom_histogram(binwidth = 0.5)
```

### 

In this case `geom_col()` won't work because it need an y aesthetic, `geom_bar()` is better than `geom_histogram()` in this scenario because `geom_bar()` automatically fixes the binwidth for you, while `geom_histogram()` requires you to set the binwidth yourself. 

### Exercise 13

Start a pipe with `tibble()`, create an value `Wshoes`, set it equal to `rnorm()`, set the first argument to 100000, the second argument `mean` equal to 8, and third argument `sd` to 1.5. Create another value `Mshoes`, set it equal to `rnorm()`, set the first argument to 100000, the second argument `mean` equal to 10.5, and third argument `sd` to 1.5.

```{r review-13, exercise = TRUE}

```

```{r review-13-hint-1, eval = FALSE}
tibble(Wshoes = rnorm(100000, mean = 8, sd = 1.5),
       Mshoes = rnorm(100000, mean = 10.5, sd = 1.5))
```

### 

Within `rnorm()` the first argument means how many times we are drawing, the second argument `mean` is the mean of the distribution, and the third argument `sd` is the standard deviation for the distribution. Normal distribution is mostly used for things that are very common for most people, but uncommon as they get far away from their average value. Examples could be height, blood pressure, IQ value, Shoe sizes, etc.

### Exercise 14

Let's prepare to plot our tibble.  Use `|>` to add the function `pivot_longer()`. Set `cols` to `everything()`, `names_to` to "Distribution", and `values_to` to  "draw".

```{r review-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r review-14-hint-1, eval = FALSE}
... |> 
    pivot_longer(cols = ...,
                 names_to = ...,
                 values to = ...)
```

###
`pivot_longer()` "lengthens" data, increasing the number of rows and decreasing the number of columns. The inverse transformation is `pivot_wider()`



### Exercise 15

Continue your pipe with `ggplot()` to map `x` to `draw` and `fill` to Distribution. Add the layer `geom_histogram()`. Within `geom_histogram()`, use `aes()` to add aesthetic with `after_stat()` . Inside `aes()`, set `y` equals to `after_stat()` with `count/sum(count)` to put percents on the y-axis.

```{r review-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r review-15-hint-1, eval = FALSE}
geom_histogram(aes(y = after_stat(count/sum(count))))
```

### Exercise 16

Set `alpha` to .5, `bins` to 100, and `position` to "identity" within `geom_histogram()`.

```{r review-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r review-16-hint-1, eval = FALSE}
... |> 
   geom_histogram(aes(y = after_stat(count/sum(count))),
                  alpha =  ..., 
                  bins =  ..., 
                  position = ...)
```

### Exercise 17

Finally, use `labs()` to title your graph "Normal Distributions of shoe sizes". Also label your x-axis "Value" and y-axis "Probability".
```{r review-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

Reminder: This is what your plot should look like. 

```{r}
shoesize_p
```


## Flipping a coin 

Let's create the following *empirical distribution* of flipping a fair coin. Recall, that empirical distribution is based on data therefore we need to simulated our data, that is "flipping the coin" by ourselves.

```{r}
emp_p <- 
  tibble(results = sample(c(0, 1), 100, replace = TRUE)) |> 
  ggplot(aes(x = results)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 0.5, 
                   color = "white") +
    labs(title = "Empirical Probability Distribution",
         subtitle = "Flipping one coin a hundred times",
         x = "Outcome\nResult of Coin Flip",
         y = "Probability") +
    scale_x_continuous(breaks = c(0, 1), 
                       labels = c("Heads", "Tails")) +
    scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
    theme_classic()

emp_p
```

### Exercise 1

Let's simulate a flipping a coin, use `sample()`, within `sample()`, set the first argument to 0 and 1, where 0 represent tails and 1 represent heads, second argument to repeat 100 times, and third argument set `replace` equal to `TRUE`, so that we can generate different values.

```{r flipping-a-coin-1, exercise = TRUE}

```

```{r flipping-a-coin-1-hint-1, eval = FALSE}
sample(..., ... , replace = ...)
```

```{r flipping-a-coin-1-hint-2, eval = FALSE}
sample(c(..., ...), 100, replace = TRUE)
```

### 

Essencially we are flipping a coin 100 times on our own on the computer. This is one way we can get access to our *population*, which contains all the data we need.


<!-- From https://stat.ethz.ch/R-manual/R-devel/library/stats/html/Binomial.html -->


### Exercise 2

Create a `tibble()` with one variable `results` . Have `results` take on the values of the `sample()` code in the previous exercise.  

```{r flipping-a-coin-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r flipping-a-coin-2-hint-1, eval = FALSE}
tibble(... = sample(..., ..., ...))
```

### 

`sample()` is what we always use in flipping coins, rolling dice, and other simple probability problems, where we can pick an value and repeat it as many times as we want.


### Exercise 3

Pipe your results to `ggplot()`. Map `results` to the x-axis. Also add the layer `geom_histogram()`. 

```{r flipping-a-coin-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r flipping-a-coin-3-hint-1, eval = FALSE}
... |> 
  ggplot(mapping = aes(...) + 
  geom_histogram()
```

### 

The `aes()` within `geom_histogram()` can only be either `x` or `y`, if you want to use both of them, use `geom_col()` or `geom_bar()` instead.

### Exercise 4

Within `geom_histogram()`, use `after_stat()` . Inside `aes()`, use `after_stat()` with the argument `y =count/sum(count)` to put percents on the y-axis.

```{r flipping-a-coin-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r flipping-a-coin-4-hint-1, eval = FALSE}
... +
    geom_histogram(aes(y = after_stat(...) 
```

### 

There are three stages where you can put aesthetic, `aes()`, first the the normal or default stage that is we set the `aes()` within ggplot. The second stage is after the data is transformed by layers like in geom_histogram(), and the third stage is after the data been transformed and scaled. Therefore, `after_stat()` is a function we use in the second stage, and it's family function `after_scale()` is used in the third stage.

### Exercise 5

Also set `binwidth` to .5 and `color` to "white" within `geom_histrogram()`.

```{r flipping-a-coin-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r flipping-a-coin-5-hint-1, eval = FALSE}
geom_histogram(aes(y = after_stat(count/sum(count))),
                 binwidth = 0.5,
                 color = "white")
```

### 

The color argument within geom_histogram(), determines the color of the bar's framework, it helps us to seperate the bars from one another. To change the color of the bar, we would use the argument fill instead of color. 

### Exercise 6

Now use `scale_x_continuous()` so the x-axis has `breaks` at 0 and 1. Set the `labels` for the breaks as "Heads" and "Tails", respectively. 


```{r flipping-a-coin-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r flipping-a-coin-6-hint-1, eval = FALSE}
Use the c() function for specifying the breaks and labels.
```

```{r flipping-a-coin-6-hint-2, eval = FALSE}
... + 
  scale_x_continuous(breaks = c(..., ...),
                     labels = c(..., ...))
```

To determine whether to use scale_x_continuous or scale_x_discrete, you need to determine the vector of the variable you want to plot, if your variable is numeric, then use `scale_x_continuous()`, if your variable is factor, then use `scale_x_discrete()`.

### Exercise 7

Now use `scale_y_continuous()` to put the y-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1.

```{r flipping-a-coin-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r flipping-a-coin-7-hint-1, eval = FALSE}
... + 
  scale_y_continuous(labels = scales::percent_format(...))
```

There is alot more function within scale_y_continuous, includes the limit, expand, guide, position, etc. To learn more about scale_continuous, click [here] (https://ggplot2.tidyverse.org/reference/scale_continuous.html)

### Exercise 8

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels.

```{r flipping-a-coin-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

Reminder: Your plot should look similar to the the one below. **Note**: the height of the bars will vary because our `rbinom()` statements generate different proportions every time! If we used the function `set.seed()` then we would be able to replicate our results. Learn more about set.seed [here](https://www.tutorialspoint.com/why-we-should-use-set-seed-in-r). 

```{r}
emp_p
```

### 

Remember the *empirical distribution* is grabbing data out of the *population*.
*Population* is the imaginary urn from which our data has been, or will be drawn. 

## Rolling Two Dice

Let's create the following *empirical distribution* for rolling two dice.

```{r}
set.seed(1)

emp_dist_dice <- tibble(ID = 1:100) |> 
  mutate(die_1 = map_dbl(ID, ~ sample(c(1:6), size = 1))) |> 
  mutate(die_2 = map_dbl(ID, ~ sample(c(1:6), size = 1))) |> 
  mutate(sum = die_1 + die_2) |> 
  ggplot(aes(x = sum)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 1, 
                   color = "white") +
    labs(title = "Empirical Probability Distribution",
         subtitle = "Sum from rolling two dice, replicated one hundred times",
         x = "Outcome\nSum of Two Die",
         y = "Probability") +
    scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) +
    scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
    theme_classic()

emp_dist_dice
```

### Exercise 1

Create a `tibble()` with variable `ID`, and the we make an list of value from 1 to 100 for the variable `ID`.

```{r rolling-two-dice-1, exercise = TRUE}

```

```{r rolling-two-dice-1-hint-1, eval = FALSE}
tibble(ID = ... : ...)
```

```{r rolling-two-dice-1-hint-2, eval = FALSE}
tibble(ID = 1:100)
```

### 

`tibble()` function provides us a framework to generate our data, this function will be used throughout this tutorial.

### Exercise 2
Nice! Now let's pipe down the tibble we create in the last exercise, let's use the `map_dbl` function to create the results for an random dice rolling experiment. recalled the` map() and map_*()` functions, within it it will includes two argument one is the data source, which in this case is `ID`. and the formula we want to use to create the dice result is the `sample()` function, and use the argument `size` within the `sample()` function to only pick one out of the six faces of a standard dice.

```{r rolling-two-dice-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-2-hint-1, eval = FALSE}
...|>
map_dbl(..., ~...)
```

```{r rolling-two-dice-2-hint-2, eval = FALSE}
...|>
map_dbl(ID, ~sample(c(...:...), size = 1))
```

This may return an error, but you may still continue on to the next exercise where the code should run without any errors.

### Exercise 3

Nice! Now let's pipe down the above and use the `mutate()` function to assign the `map_dbl` functions we above to an value called "die_1".


```{r rolling-two-dice-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-3-hint-1, eval = FALSE}
...|>
mutate(... =map_dbl(ID, ~sample(c(...:...), size = 1)))
```

```{r rolling-two-dice-3-hint-2, eval = FALSE}
...|>
mutate(die_1 = map_dbl(ID, ~ sample(c(1:6), size = 1))) |> 
```

### Exercise 4

Now copy and paste the results from above, and do the exact same thing again but instead row named to value to `die_2`, because we need the results for two dices.


```{r rolling-two-dice-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-4-hint-1, eval = FALSE}
...|>
mutate(... =map_dbl(ID, ~sample(c(...:...), size = 1)))
```

```{r rolling-two-dice-4-hint-2, eval = FALSE}
...|>
mutate(die_2 = map_dbl(ID, ~ sample(c(1:6), size = 1))) |> 
```

### Exercise 5

Use the `mutate()` function once again, name the value of the sum of `die_1` and `die_2` to "sum"


```{r rolling-two-dice-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-5-hint-1, eval = FALSE}
...|>
mutate(sum = die_1 + die_2)
```

### Exercise 6

Copy and paste the results from above, now use `ggplot()` to graph the Empirical Distribution, set `x = sum` within `aes()`, and then add a layer of `geom_histogram()`


```{r rolling-two-dice-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-6-hint-1, eval = FALSE}
...|>
ggplot(aes())+
  geom_histogram()
```

### Exercise 7

Within `geom_histogram()`, use `after_stat()` . Inside `aes()`, use `after_stat()` with the argument `y =count/sum(count)` to put percents on the y-axis.

```{r rolling-two-dice-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-7-hint-1, eval = FALSE}
... +
    geom_histogram(aes(y = after_stat(...)))
```

### Exercise 8

Also set `binwidth` to .5 and `color` to "white" within `geom_histrogram()`.

```{r rolling-two-dice-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>


```{r rolling-two-dice-8-hint-1, eval = FALSE}
... +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 1, 
                   color = "white") 
```

### Exercise 9

Now use `scale_x_continuous()` so the x-axis has `breaks` to the sequence between 2 and 12 common difference is 1 using `seq()`. Set the `labels` for the breaks as from 2 to 12.


```{r rolling-two-dice-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-9-hint-1, eval = FALSE}
scale_x_continuous(breaks = seq(...,..., ...), labels = ...:...) 
```

```{r rolling-two-dice-9-hint-2, eval = FALSE}
... + 
  scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) 
```

### Exercise 10

Now use `scale_y_continuous()` to put the x-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1.

```{r rolling-two-dice-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-10-hint-1, eval = FALSE}
... + 
  scale_y_continuous(labels = scales::percent_format(...))
```

### Exercise 11

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels. Also add the layer `theme_classic()`.

```{r rolling-two-dice-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

Reminder: Your plot should look similar to the the one below. 

```{r}
emp_dist_dice
```

## Height

Let's create the following *empirical distribution* about the "height of the next adult men you'll meet" using the data from the National Health and Nutrition Examination Survey (NHANES).

```{r}
emp_height <- nhanes |>
  filter(gender == "Male", age >= 18) |>
  select(height)|>
  drop_na() |>
  ggplot(aes(x = height)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                 binwidth = 1, 
                 color = "white")+
  labs(title = "Empirical Probability Distribution",
       subtitle = "Height for male by NHANES",
       x = "Height",
       y = "Probability",caption = "Source:NHANES") +
  scale_y_continuous(labels =
                      scales::percent_format(accuracy = 1)) +
  theme_classic()
emp_height
```

### Exercise 1

glimpse the package `nhanes`

```{r height-1, exercise = TRUE}

```

```{r height-1-hint-1, eval = FALSE}
glimpse(nhanes)
```

Note that there is all sorts of column in this data set, but the two that we actually care about is gender and height.
 
### Exercise 2

Start a new pipe with `nhanes`, use `filter()` to filter the rows where gender is equal to "Male", and age is greater or equal to 18

```{r height-2, exercise = TRUE}

```

```{r height-2-hint-1, eval = FALSE}
nhanes |>
  filter(gender == ..., age >= ...) 
```

```{r height-2-hint-2, eval = FALSE}
nhanes |>
  filter(gender == "Male", age >= 18) 
```

### Exercise 3

Use `select()` to pick out "height" column which is what we want.Then use `drop_na()` to drop the rows that contains NA which we don't want. 


```{r height-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r height-3-hint-1, eval = FALSE}
...|>
  select(height)|>
  drop_na()
```

### Exercise 4

Use `ggplot()` and `geom_histogram()` to graph out the distribution, set x equal to "height" within `ggplot()`.


```{r height-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r height-4-hint-1, eval = FALSE}
...|>
  ggplot(aes(x=...)) +
  geom_histogram()
```

### Exercise 5

Within `geom_histogram()`, use `aes()` . Inside `aes()`, set `y` equal to `after_stat()` with the argument `count/sum(count)` to put percents on the y-axis.


```{r height-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r height-5-hint-1, eval = FALSE}
... +
    geom_histogram(aes(y = after_stat(...))) 
```

### Exercise 6

Also set `binwidth` to .5 and `color` to "white" within `geom_histrogram()`.

```{r height-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r height-6-hint-1, eval = FALSE}
... +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = .5, 
                   color = "white") 
```

### Exercise 7

Now use `scale_y_continuous()` to put the y-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1.

```{r height-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r height-7-hint-1, eval = FALSE}
... + 
  scale_y_continuous(labels = scales::percent_format(...))
```

### Exercise 8

Finally, use `labs()` to add the appropriate title, subtitle, axis labels, and caption. Also add the layer `theme_classic()`.

```{r height-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

Reminder: Your plot should look exatly like this one because we used the exact same data from nhanes.
```{r}
emp_height
```

## Three Models 

### 

Let's create the following *joint distribution* of the number of white marbles in a bag and the number of white marbles pulled out in the sample.

```{r}
joint_p <- tibble(in_bag = rep(c(0, 1, 2), 1000)) |>
  mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1, 
                                              size = 3, 
                                              p = ./2))) |>
  ggplot(aes(x = in_sample, y = in_bag)) +
    geom_jitter(alpha = 0.5) +
    labs(title = "Black and White Marbles",
         subtitle = "More white marbles in bag mean more white marbles selected",
         x = "White Marbles Selected",
         y = "White Marbles in the Bag") +
    scale_y_continuous(breaks = c(0, 1, 2)) +
  theme_classic()

joint_p
```

### Exercise 1

Create a `tibble()` with one variable `in_bag`. Have `in_bag` take on the values of `rep()`. Within `rep()` use the arguments 0, 1, and 2. 

```{r three-models-1, exercise = TRUE}

```

```{r three-models-1-hint-1, eval = FALSE}
tibble(in_bag = rep(c(..., ..., ...)))
```

Great. We now have generated the number of white marbles that exist in our bag. 

### Exercise 2

Great. Let's have our code run 1000 times. Add the argument 1000 to `rep()`

```{r three-models-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>


```{r three-models-2-hint-1, eval = FALSE}
 tibble(in_bag = rep(c(0, 1, 2), ...))
```

### Exercise 3

Use `mutate()`, create a new column name `in_sample`, and set `in_sample` equal to `rbinom()` where `n` is set to 1, `size` is set to 3, and `p` is set to `in_bag/2`. Note that this should returns same values for all 3000 rows under `in_sample`
`
```{r three-models-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r three-models-3-hint-1, eval = FALSE}
 |>
  mutate(in_sample = rbinom(n = 1, size =3 , p = in_bag/2))
```

### 

This is because rbinom only generate 1 values, so r compied and paste that value for all rows to match the 3000 values in the first column.

### Exercise 4

Now set `in_sample` to the function `map_int()`. The first argument to `map_int()` should be `in_bag`. The second argument should be an `rbinom()` where `n` is set to 1, `size` is set to 3, and `p` is set to `./2`.
```{r three-models-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r three-models-4-hint-1, eval = FALSE}
... |> 
  mutate(in_sample = map_int(..., ~ rbinom(..., 
                                           ..., 
                                           ...)))
```

### 

The `.` essencially means carrying the data from the first argument (in_bag) to the operation, it is the same as `in_bag/2`.


### Exercise 5

Pipe your result into `ggpplot()`. Map `in_sample` to the x-axis and `in_bag` to the y-axis. Also add the layer `geom_jitter()`. 

```{r three-models-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>


```{r three-models-5-hint-1, eval = FALSE}
... |> 
  ggplot(aes(x = ..., y = ...)) +
    geom_jitter()
```

### Exercise 6

Set `alpha` to .5 within `geom_jitter()`. 

```{r three-models-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>


```{r three-models-6-hint-1, eval = FALSE}
... +
    geom_jitter(...)
```

### Exercise 7

Now use `scale_y_continuous()` to break the y-axis into three values. Within `scale_y_continuous()`, set `breaks` to 0, 1, and 2.

```{r three-models-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r three-models-7-hint-1, eval = FALSE}
... + 
  scale_y_continuous(breaks = c(..., ..., ...)
```

Why do we do this? Each value on the y-axis represents a different version or belief about the world.

### Exercise 8

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels. Also add the layer `theme_classic()`.

```{r three-models-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

Reminder: This is what your plot should look like.

```{r}
joint_p
```

```{r three-models-8-hint-1, eval = FALSE}

```

### 

Awesome. We can now see the number of simulations in each "bucket." Take note that this distribution is normalized.

### 

Let's create the following *unnormalized conditional distribution*. This is essentially a slice of the joint distribution we previously created. 

```{r}
unnorm_p <- tibble(in_bag = rep(c(0, 1, 2), 1000)) |>
  mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1, 
                                              size = 3, 
                                              p = ./2))) |> 
  filter(in_sample == 3) |> 
  ggplot(aes(in_bag)) +
    geom_histogram(binwidth = 0.25, color = "white") +
    labs(title = "Unnormalized Conditional Distribution",
         subtitle = "Number of white marbles in bag given that three were selected in the sample",
         x = "Number of White Marbles in the Bag",
         y = "Count") +
    scale_x_continuous(breaks = seq(1, 2)) +
    theme_classic()

unnorm_p
```

### Exercise 9

Copy down every part of the empirical distribution before `ggplot()` and then use `filter()` for where `in_sample` is equal to 3.

```{r three-models-9, exercise = TRUE}

```

```{r three-models-9-hint-1, eval = FALSE}
...|> 
  filter(in_sample == ...)
```

### Exercise 10

Pipe your code above to `ggplot()`. Map `in_bag` to the x-axis. Also add the layer `geom_histogram()`.

```{r three-models-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r three-models-10-hint-1, eval = FALSE}
... |> 
  ggplot(aes(...)) +
  geom_histogram()
```

### Exercise 11

Set `binwidth` to .25 and `color` to "white" within `geom_histogram()`.

```{r three-models-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r three-models-11-hint-1, eval = FALSE}
... +
  geom_histogram(..., ...)
```

### Exercise 12

Now use `scale_x_continuous()`. Set `breaks` to `seq()` that contains the values 1 and 2.

```{r three-models-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r three-models-12-hint-1, eval = FALSE}
... +
  scale_x_continuous(... = seq(..., ...))
```

### Exercise 13

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels. Also add the layer `theme_classic()`.

```{r three-models-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

Reminder: This is what your plot should look like.

```{r}
unnorm_p
```

### 

Let's create the following *normalized conditional distribution*. In other words, we are normalizing the graph we just created.

```{r}
norm_p <- tibble(in_bag = rep(c(0, 1, 2), 1000)) |>
  mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1, 
                                              size = 3, 
                                              p = ./2))) |> 
  filter(in_sample == 3) |> 
  ggplot(aes(in_bag)) +
    geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 0.25, 
                   color = "white") +
    labs(title = "Posterior Probability Distribution",
         subtitle = "Number of white marbles in bag given that three were selected in the sample",
         x = "Number of White Marbles in the Bag",
         y = "Probability") +
    scale_x_continuous(breaks = c(1, 2)) +
    scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
    theme_classic()

norm_p
```

### Exercise 14

We begin our code the same way we began our code for the *unnormalized conditional distribution*. We have provided the code for you below. To begin, within `aes()` use `after_stat()` with the argument `y = count/sum(count)` to put percents on the y-axis.


```{r three-models-14, exercise = TRUE}
tibble(in_bag = rep(c(0, 1, 2), 1000)) |>
  mutate(in_sample = map_int(in_bag, ~ rbinom(n = 1, 
                                              size = 3, 
                                              p = ./2))) |> 
  filter(in_sample == 3) |> 
  ggplot(aes(in_bag)) +
    geom_histogram(binwidth = 0.25, color = "white")
```

```{r three-models-14-hint-1, eval = FALSE}
... +
  geom_histogram(binwidth = 0.25, color = "white",aes(y = after_stat(count/sum(count)))
```

### Exercise 15

Now use `scale_x_continuous()` so the x-axis has `breaks` at 1 and 2.

```{r three-models-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r three-models-15-hint-1, eval = FALSE}
Use the c() function for specifying the breaks and labels.
```

```{r three-models-15-hint-2, eval = FALSE}
... + 
  scale_x_continuous(breaks = c(..., ...))
```

### Exercise 16

Now use `scale_y_continuous()` to put the y-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1.

```{r three-models-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r three-models-16-hint-1, eval = FALSE}
... + 
  scale_y_continuous(labels = scales::percent_format(...))
```

### Exercise 17

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels. Also add the layer `theme_classic()`.

```{r three-models-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

Reminder: This is what your plot should look like.

```{r}
norm_p
```

## N Models 

### 

Let's create the following *empirical distribution* for possible simulations for $\rho_h$. In other words, we will create a joint distribution of models which might be true and of data which our experiment might generate. 

```{r}
emp_p <- tibble(p = rep(seq(0, 1, 0.1), 1000)) |>
  mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) |>
  ggplot(aes(y = p, x = heads)) +
    geom_jitter(alpha = 0.1) +
    labs(title = "Empirical Distribution of Number of Heads",
         subtitle = expression(paste("Based on simulations with various values of ", rho[h])),
         x = "Number of Heads out of 20 Tosses",
         y = expression(rho[h])) +
  scale_y_continuous(breaks = seq(0, 1, 0.1)) +
  theme_classic()

emp_p
```

### Exercise 1

Use `tibble()` with one variable `p` set to the function `rep()`. Within `rep()` use the argument `seq()` that takes on the values 0, 1, and .1.

```{r n-models-1, exercise = TRUE}

```

```{r n-models-1-hint-1, eval = FALSE}
tibble(... = rep(seq(..., ..., ...)))
```

###
`seq()` generate regular sequences. `seq.int()` is a primitive which can be much faster but has a few restrictions. `seq_along()` and `seq_len()` are very fast primitives for two common cases.

### Exercise 2

Great. Let's have our code run 1000 times. Add the argument 1000 to `rep()`

```{r n-models-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r n-models-2-hint-1, eval = FALSE}
 tibble(p = rep(c(0, 1, .1), ...))
```

### Exercise 3

Pipe your code to the function `mutate()` to create the variable `heads`. Set `heads` to the function `map_int()`. The first argument to `map_int()` should be `p`. The second argument should be an `rbinom()` where `n` is set to 1, `size` is set to 20, and `p` is set to `.`.

```{r n-models-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r n-models-3-hint-1, eval = FALSE}
 ... |> 
  mutate(p = map_int(..., ~ rbinom(...,
                                   ..., 
                                   ...)))
```

###
This `.` means that we are carrying the data source which is `p` and applied it as the probability of our `rbinom()` function.

### Exercise 4

Continue your pipe to `ggplot()`. Map `heads` to the x-axis and `p` to the y-axis. Also add the layer `geom_jitter()`. 

```{r n-models-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r n-models-4-hint-1, eval = FALSE}
  ggplot(aes(x = ..., y = ...)) +
    geom_jitter()
```

###
`geom_jitter()` is a convenient shortcut for `geom_point(position = "jitter")`. It adds a small amount of random variation to the location of each point, and is a useful way of handling overplotting caused by discreteness in smaller datasets.

### Exercise 5

Set `alpha` to .1 within `geom_jitter()`. 

```{r n-models-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r n-models-5-hint-1, eval = FALSE}
... +
  geom_jitter(...)
```

### Exercise 6

Now use `scale_y_continuous()`. Set `breaks` to the function `seq()` that contains the values 0, 1, and .1.

```{r n-models-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r n-models-6-hint-1, eval = FALSE}
... + 
  scale_y_continuous(breaks = seq(..., ..., ...)
```

### Exercise 7

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels. Also add the layer `theme_classic()`.

```{r n-models-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

Reminder: This is what your plot should look like.

```{r}
emp_p
```

### 

Let's create the following *unnormalized conditional distribution*. This is essentially a slice of the joint distribution we previously created. 

```{r}
unnorm_p <- tibble(p = rep(seq(0, 1, 0.1), 1000)) |>
  mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) |> 
  filter(heads == 8) |> 
  ggplot(aes(p)) +
    geom_bar() +
    labs(title = expression(paste("Values of ", rho[h], " Associated with 8 Heads")),
         x = expression(paste("Assumed value of ", rho[h], " in simulation")),
         y = "Count") +
  theme_classic()

unnorm_p
```

### Exercise 8

Copy the code from exercise 7 upto ggplot. Pipe this to `filter()` for where `heads` is equal to 8.

```{r n-models-8, exercise = TRUE}

```

```{r n-models-8-hint-1, eval = FALSE}
  filter(heads == ...)
```

### Exercise 9

Pipe your code above to `ggplot()`. Map `p` to the x-axis.  Also add the layer `geom_bar()`.

```{r n-models-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r n-models-9-hint-1, eval = FALSE}
... |> 
  ggplot(aes(...)) +
  geom_histogram()
```

### Exercise 10

Finally, use `labs()` to add the title "Values of P(h) with 8 Heads". Then label your x-axis "Assumed value of P(h) in simulation". Also add the layer `theme_classic()`.

```{r n-models-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

Reminder: This is what your plot should look like.

```{r}
unnorm_p
```

### 

Let's create the following *normalized conditional distribution*. In other words, we are normalizing the graph we just created.

```{r}
norm_p <-tibble(p = rep(seq(0, 1, 0.1), 1000)) |>
  mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) |> 
  filter(heads == 8) |> 
  ggplot(aes(x = p)) +
    geom_histogram(aes(y = after_stat(count/sum(count))),
                   bins = 50) + 
    labs(title = expression(paste("Posterior Probability Distribution of ", rho[h])),
         x = expression(paste("Possible values for ", rho[h])),
         y = "Probability") +
    scale_x_continuous(breaks = seq(0.2, 0.7, by = 0.1)) +
    scale_y_continuous(labels = 
                        scales::percent_format(accuracy = 1)) +
  theme_classic()

norm_p

```

### Exercise 11

We begin our code the same way we began our code for the *unnormalized conditional distribution*. We have provided the code for you below. To begin, add the layer `geom_histogram()` and set `bins` to 50.


```{r n-models-11, exercise = TRUE}
 tibble(p = rep(seq(0, 1, 0.1), 1000)) |>
  mutate(heads = map_int(p, ~ rbinom(n = 1, size = 20, p = .))) |> 
  filter(heads == 8) |> 
  ggplot(aes(x = p))
```

```{r n-models-11-hint-1, eval = FALSE}
... +
  geom_histogram(...)
```

### Exercise 12

Within `geom_histogram()`, use `after_stat()` . Inside `aes()` with the argument `y = count/sum(count)` use `after_stat()` to put percents on the y-axis.


```{r n-models-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r n-models-12-hint-1, eval = FALSE}

```

### Exercise 13

Now use `scale_x_continuous()`. Set `breaks` to `seq()` that contains the values 0.2 and 0.7. Also set `by` to 0.1 within `seq()`.

```{r n-models-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r n-models-13-hint-1, eval = FALSE}
... +
  scale_x_continuous(... = seq(..., ..., ...))
```

### Exercise 14

Now use `scale_y_continuous()` to put the y-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1.

```{r n-models-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>


```{r n-models-14-hint-1, eval = FALSE}
... + 
  scale_y_continuous(labels = scales::percent_format(...))
```

### Exercise 15

Finally, use `labs()` to add the title "Posterior Probability Distribution of P(h)". Then label your x-axis "Possibility values for P(h)" and y-axis "Probability". Also add the layer `theme_classic()`.


```{r n-models-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

Reminder: This is what your plot should look like.

```{r}
norm_p
```

## Summary

### 

After finishing this tutorial you should be able to... 

  1. Use `tibble()`, `map()` / `map_*()` combine with other functions like `rep()` and  `sample()` to simulate/generate data.

  2. Identify and transform normalized/normalized distribution.

  3. Understand that conditional distribution is an "slice" of the joint distribution.




```{r download-answers, child = "../../child_documents/download_answers.Rmd"}
```
