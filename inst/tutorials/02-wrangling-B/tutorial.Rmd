---
title: "Wrangling B"
tutorial:
  id: "wrangling-b"
output:
  learnr::tutorial:
      progressive: true
      allow_skip: true
runtime: shiny_prerendered
description: "Chapter 2 Tutorial -- Part A"
---

<!-- Things to fix in this tutorial. -->

<!-- BG: I deleted the "to-fix" comments of this tutorial. They were to add intro sentences under section headers and to use read* functions. However, we have a separate tutorial for read_csv() and I added intro sentences under sections. -->


```{r setup, include = FALSE}
library(learnr)
library(primer.tutorials)
library(tidyverse)
library(lubridate)
library(stringr)
library(skimr)
library(ranger)
library(primer.data)
library(nycflights13)


knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 



```


## Information
###

```{r information}
quiz(caption = "",
  question_text(
    "Name:",
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL),
  question_text(
    "Email:",
    answer(NULL, correct = TRUE),
    allow_retry = TRUE,
    try_again_button = "Edit Answer",
    incorrect = NULL))
```



## Characters 
###

A string is one or more characters that are enclosed inside a pair of matching 'single' or "double quotes". We will now use various functions to manipulate strings

### Exercise 1

Type `state.name` into the code chunk below to inspect a character vector that contains the names of all US states.

```{r exercise-2-1, exercise = TRUE}

```

```{r exercise-2-1-hint, eval = FALSE}
Type `state.name` and press Run Code
```

### Exercise 2

Use `str_detect()` on `state.name` to create a vector which will be TRUE for states which contain the pattern "ana" and FALSE otherwise.

```{r exercise-2-2, exercise = TRUE}

```

```{r exercise-2-2-hint, eval = FALSE}
str_detect(..., pattern = ...)
```


### Exercise 3

Use `str_subset()` on `state.name` to create a vector of the names of the states that contain the pattern "ana".

```{r exercise-2-3, exercise = TRUE}

```

```{r exercise-2-3-hint, eval = FALSE}
str_subset(..., pattern = ...)
```

### Exercise 4

Now use `str_split()` on `state.name` in order to help identify states which involve two or more words in their names (i.e. have spaces). Set `simplify` argument to TRUE. The result will be a character matrix with 51 rows and three columns.

```{r exercise-2-4, exercise = TRUE}

```

```{r exercise-2-4-hint-1, eval = FALSE}
A " " is the simple version of a pattern which identifies words spaces.
````

```{r exercise-2-4-hint-2, eval = FALSE}
str_split(..., pattern = ..., simplify = TRUE)
```


### Exercise 5

Try again to identify states whose names consist of two or more words, this time using `str_split_fixed()`.  Set the `n` argument to 2, which should split elements into two parts.

```{r exercise-2-5, exercise = TRUE}

```

```{r exercise-2-5-hint, eval = FALSE}
str_split_fixed(..., pattern = ..., n = ...)
```

### Exercise 6

Using `str_sub`, create a character vector that contains only the first three letters of each state.

```{r exercise-2-6, exercise = TRUE}

```

```{r exercise-2-6-hint, eval = FALSE}
str_sub(state.name, 1, 3)
```


### Exercise 7

Collapse `state.name` using `str_c()`. Separate them with a comma that is followed by a whitespace. This should create a single character object with all the states.

```{r exercise-2-7, exercise = TRUE}

```

```{r exercise-2-7-hint, eval = FALSE}
str_c(..., collapse = ", ")
```

### Exercise 8

Use `str_replace()` to replace the pattern `North` with `N.`. For example, transform North Carolina into N. Carolina.

```{r exercise-2-9, exercise = TRUE}

```

```{r exercise-2-9-hint, eval = FALSE}
str_replace(..., pattern = ..., replacement = "...")
```

### Exercise 10

Next, let's see how the above functions can be combined with regular expressions. Use `str_subset()` on `state.name` to create a vector of states that have two a's with a single intervening character in their name:

```{r exercise-2-10, exercise = TRUE}

```

```{r exercise-2-10-hint-1, eval = FALSE}
Consider using the regex "."
```

```{r exercise-2-10-hint-2, eval = FALSE}
str_subset(..., pattern = ...)
```

### Exercise 11

Use `str_subset()` to identify the same pattern as in the previous question, including now only those states where the pattern occurs at the end of their name.

```{r exercise-2-11, exercise = TRUE}

```

```{r exercise-2-11-hint-1, eval = FALSE}
Consider using the pattern "a.a$"
```

```{r exercise-2-11-hint-2, eval = FALSE}
str_subset(..., pattern = ...)
```

### Exercise 13

Now count the characters in your strings. Use `str_length()` with the argument `my_state`

```{r exercise-2-15-setup}
my_state <- str_subset(state.name, pattern = "a.+a")
```

```{r exercise-2-15, exercise = TRUE}

```

```{r exercise-2-15-hint, eval = FALSE}
str_length(...)
```

### Exercise 12

Use `str_subset()` to find `state.name` that contain the letter "a" and then one or more characters and another a. 

```{r exercise-2-12, exercise = TRUE}

```

```{r exercise-2-12-hint-1, eval = FALSE}
Consider using the pattern "a.+a"
```

```{r exercise-2-12-hint-2, eval = FALSE}
str_subset(..., pattern = ...)
```

This is our answer:

```{r}
str_subset(state.name, pattern = "a.+a")
```



## Factors 
###

Factors are categorical variables that may only take on a specified set of values. 

### Exercise 1

Use `select()` to look at the `ideology` variable of the `cces` data set. 

```{r factors-1, exercise = TRUE}
cces %>% select(ideology)
```


### Exercise 2

Use `str()` with the argument `cces$ideology`. Then on the line below, use `levels()` with the same argument. 


```{r factors-3, exercise = TRUE}

```

### Exercise 3

Let's now get a frequency table as a tibble. Use `fct_count()` with the argument `cces$ideology`.


```{r factors-4, exercise = TRUE}

```


```{r factors-4-hint, eval = FALSE}
fct_count(...)
```

### Exercise 4

Now use `nlevels()` with the argument `cces$ideology` to find the number of existing levels.


```{r factors-5, exercise = TRUE}

```

```{r factors-5-hint-1, eval = FALSE}

```

### Exercise 5

Now filter `cces` to to only a few ideologies: `Conservative` , `Moderate`, `Liberal` and `Not Sure`. save your work to an object named `cces_filt`.

```{r factors-6, exercise = TRUE}

```

```{r factors-6-hint, eval = FALSE}
cces_filt <- c(...)
```


### Exercise 6

Now use `nlevels()` with the argument `cces_filt`. Notice the same number of levels pop up.

```{r factors-7, exercise = TRUE}

```

```{r factors-7-hint, eval = FALSE}
nlevels(...)
```

### Exercise 7

Let's drop all the unused levels. Start your code with `cces_filt` and use `%>%` to add the function `droplevels()`. Then on the line below, use `nlevels()` once gain to see how many levels exist. Notice the difference?


```{r factors-8, exercise = TRUE}

```

```{r factors-8-hint, eval = FALSE}
cces_filt %>% 
  droplevels()
nlevels(...)
```

### Exercise 8

Now try ordering the levels by frequency using `fct_infreq()`. Then, use `levels()` to display the levels by frequency.


```{r factors-9, exercise = TRUE}

```

```{r factors-9-hint, eval = FALSE}
cces_filt %>% 
  ... %>% 
  ...
```

## Lists
###

A list is the object which contains various data types such as logicals, integers, characters, and even another list!


### Exercise 1

Create a list with three items `a`, `b`, and `c`. Let `a` be a vector containing 1, 2, and 3. Let `b` be a vector containing 4, 5, and 6, and let `c` be a vector containing 7, 8, and 9. Assign your list to an object named `my_list`.


```{r lists-1, exercise = TRUE}

```

```{r lists-1-hint, eval = FALSE}
Use the c() function to create the individual vectors for a, b, and c. 
Use the assignment operator, <- , to save your values to an object.
```

### Exercise 2

Now, call `str()` on `mylist`. 

```{r lists-2-setup}
mylist <- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))
```

```{r lists-2, exercise = TRUE}

```

### Exercise 3

Let's now extract a single component `a` from `mylist`

```{r lists-4-setup}
mylist <- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))
```

```{r lists-4, exercise = TRUE}

```

```{r lists-4-hint-1, eval = FALSE}
str(...[" "])
```


### Exercise 4

Now, extract the number 5 from `mylist`.

```{r lists-5-setup}
mylist <- list(a = c(1, 2, 3), b = c(4, 5, 6), c = c(7, 8, 9))
```

```{r lists-5, exercise = TRUE}

```

```{r lists-5-hint-1, eval = FALSE}
str(...[ ])
```



## Combining Data
###

Bringing together data from different sources is one of the most common data science tasks. 


### Exercise 1

Inspect the dataset `band_instruments` by typing its name below and hitting Run Code.

```{r exercise-combining-1, exercise = TRUE}

```

```{r exercise-combining-1-hint, eval = FALSE}
band_instruments
```



### Exercise 2

Press run code to look at the following data frames.

```{r question-combining-3, exercise = TRUE}
band_instruments
band_instruments2
band_members
```

Consider the discrepancy between the columns of `band_instruments2` and the columns of both `band_members` and `band_instruments`. Predict, in your head, what will happen when binding the rows of the two tibbles.


### Exercise 3

Use `bind_rows()` to combine the two data frames `band_instruments2` and `band_members`.

```{r question-combining-5, exercise = TRUE}


```

```{r question-combining-5-hint, eval = FALSE}
bind_rows(band_instruments2, ...)
```

This is, probably, not what we want.

### Exercise 4

Use the extraction operator `$` on the `plays` column of `band_instruments`.

```{r question-combining-11, exercise = TRUE}

```

```{r question-combining-11-hint, eval = FALSE}
band_instruments$...
```

### Exercise 5

Now use `inner_join()` with the `band_instruments` and `band_instruments2` tibbles with the `by` argument set to "plays". 

```{r question-combining-13, exercise = TRUE}

```

```{r question-combining-13-hint, eval = FALSE}
inner_join(..., ..., by = ...)
```

The fact that one tibble uses the word "name" and the other "artist" for the same thing causes trouble when we try to bring the data together.

### Exercise 6

Let's focus on the `band_members` and `band_instruments` tibbles for the remaining questions in this session. Always try to predict, in your head, what result a given join function will produce before you run in.

Use `left_join()` with `band_members` as the first argument and `band_instruments` as the second.

```{r, cd-ex-6, exercise = TRUE}

```

```{r, cd-ex-6-hint, eval = FALSE}
left_join(band_members, ...)
```

Your results should look like this:

```{r}
left_join(band_members, band_instruments)
```

Note how Keith disappears because he does not appear in `band_members`. Note how what Mick plays is NA because there is no corresponding row in band_instruments.

### Exercise 7

Use `left_join()` with `band_instruments` as the first argument and `band_members` as the second.

```{r, cd-ex-7, exercise = TRUE}

```

```{r, cd-ex-7-hint, eval = FALSE}
left_join(band_instruments, ...)
```

Your results should look like this:

```{r}
left_join(band_instruments, band_members)
```

Keith is back but John has disappeared. Whenever we use `left_join()`, the rows kept are determined by the first tibble.

<!-- DK: Could do some more. -->

## Date-Times 
###

Let's practice using some functions that work with date and time.

### Exercise 1

Run the `today()` and `now()` functions below.

```{r dttm-1, exercise = TRUE}

```

### Exercise 2

Now use the function `ymd()` to convert the string below into the proper date-time format. 

```{r dttm-2, exercise = TRUE}
date_1 <- "2020-2-29"
```

### Exercise 3

Now create a date-time by adding an underscore then “h,” “m,” and “s” to the name of the `ymd()` parsing function.

```{r dt-3, exercise = TRUE}
date_2 <- "2017-01-31 20:11:59"

```

```{r dt-3-hint, eval = FALSE}
ymd_hms(...)
```

```{r}

```


### Exercise 4

The following code below has selected time data in the`flights` dataset. Use `mutate()` to create a variable `arrival`. `arrival` should equal the functio `make_datetime()` with all selected variables as its argument.

```{r dttm-3, exercise = TRUE}
flights %>% 
  select(year, month, day, hour, minute)
```

```{r dttm-3-hint, eval = FALSE}
flights %>% 
  select(year, month, day, hour, minute) %>% 
  mutate(... = make_datetime(year, ...,...,..., ...))
```


## Tidying Data
###

For a dataset to be tidy, each variable must have its own column, each observation must have its own row, and each value must have its own cell.

### Exercise 1

Run `relig_income` in the code chunk below. Notice how wide it is.

```{r tidy-5, exercise = TRUE}

```

### Exercise 3

You can use the `pivot_longer()` to convert wide data to long data. Let's use the `pivot_longer` to tidy the `relig_income` data. Pivot all columns except for the `cols` to everything but the `religion` column. Set `names_to` to "income" and`values_to` to "count". Set the new name to "year" and the new values to "cases".

```{r tidy-7, exercise = TRUE}

```

```{r tidy-7-hint-1, eval = FALSE}
Consider using - to select the columns you want to pivot
```

```{r tidy-7-hint-2, eval = FALSE}
relig_income %>% 
  pivot_longer(-religion,
  names_to = ...,
  values_to = ...)
```

### Exercise 4

Let's now look at the `us_rent_income` data set. Call the data set below. 

```{r tidy-ee, exercise = TRUE}

```

```{r tidy-ee-hint, eval = FALSE}

```

### Exercise 5

You can "spread" the keys in a key column across their own set of columns with the `pivot_wider()`. Set `names_from` to `variable` and set `values_from`  to `c(estimate, moe))`.


```{r tidy-12, exercise = TRUE}

```

```{r tidy-12-hint, eval = FALSE}
... %>% 
  pivot_wider(names_from = ..., 
              values_from = ..., 
              names_prefix = ...)
```




## Submit

```{r context="setup"}
submission_ui
```

```{r context="server"}
submission_server()
```

