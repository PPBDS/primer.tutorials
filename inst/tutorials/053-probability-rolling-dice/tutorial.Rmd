---
title: "Probability: Rolling Dice"
author: Yuhan Wu
tutorial:
  id: probability-rolling-dice
output:
  learnr::tutorial:
    progressive:  true
    allow_skip::  true
runtime: shiny_prerendered
description: "Exploring simple dice rolls under various scenarios."
---

```{r setup, include = FALSE}
library(learnr)
library(all.primer.tutorials)
library(tidyverse)
library(primer.data)
library(forcats)
knitr::opts_chunk$set(echo = FALSE)
options(tutorial.exercise.timelimit = 60, 
        tutorial.storage = "local") 
```

```{r copy-code-chunk, child = system.file("child_documents/copy_button.Rmd", package = "tutorial.helpers")}
```

```{r info-section, child = system.file("child_documents/info_section.Rmd", package = "tutorial.helpers")}
```

<!-- DK: Graphic for weighted die should be from 2 to 12, not 5 to 12. Maybe cheat a bit and choose a set seed which produces a 50 sample graphic that might fool us. -->

<!-- Review all current code and clean it up. -->

<!-- Key insight: We are in the business of comparing the model --- a data generating mechanism (DGM) which we create with code --- with the data. In particular, we simulate from 10,000 draws (or create or just draw) from the DGM. Then, we look at the data we have. How well do those match up? If they match up OK, then we are good! If they match up poorly, we need a new DGM.  -->


<!-- Perhaps use the Statistical Rethinking chapter 2 example which is similar to, but more complex than, our  -->




## Introduction
###

Official Definition: We use the term '**d**ata-**g**enerating **m**echanism' (DGM) to denote how random numbers are used to generate a dataset." 


By it's name, a data generating mechanism generates data that we need in order to solve problems. We can generate data because we assume that we know the mathematical formula for the population of data which is the infinite set of data we want and need. 

###

After this tutorial you will be able to answer the following questions:  

How sample size will effect empirical distribution and data generating mechanism?  

How does different assumptions change the DGM ?  

How to determine if the assumptions for DGM is false?  



## Two dice

### 

The larger the sample size, the more closely your empirical distribution will match the data generating mechanism (DGM) **if** your assumptions about the DGM are correct.

### 

For example, you might think that the two dice are fair and that, therefore, the data generating mechanism --- which is a tool you can use, for example, to forecast future rolls --- is defined as:

<!-- DK: Not sure I like this p_x(X) stuff. Need to revisit, both here and in the Primer. -->

$$ p_Y(y) = \begin{cases} \dfrac{y-1}{36} &\text{for }y=1,2,3,4,5,6 \\ \dfrac{13-y}{36} &\text{for }y=7,8,9,10,11,12 \\ 0 &\text{otherwise} \end{cases} $$

This is of course the mathematical distribution for fair dice. Graphically, it looks like:


```{r}
tibble(sum = c(rep(c(2, 12), 1), 
               rep(c(3, 11), 2),
               rep(c(4, 10), 3), 
               rep(c(5,  9), 4),
               rep(c(6,  8), 5),
               rep(c(7), 6))) |> 
  ggplot(aes(x = sum)) +
  geom_histogram(aes(y = after_stat(count/sum(count))), 
                   binwidth = 1, 
                   color = "white") +
  labs(title = "Mathematical Probability Distribution",
         subtitle = "Expectation for the sum from rolling two dice",
         x = "Outcome\nSum of Two Die",
         y = "Probability") +
  scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) +
  scale_y_continuous(labels = 
                         scales::percent_format(accuracy = 1)) +
  theme_classic()
```

###


This is the plot we will replicate.

```{r}
# Turn your N column into a factor and then give it the levels in the order you
# want it to be. Maybe use forcats. Consider having the plot by 6 x 1. Or maybe
# stacked but with only 4 N values.


set.seed(2)
dice_p <- tibble(N = c(rep("10", 10), 
                       rep("20", 20),
                       rep("50", 50),
                       rep("100", 100),
                       rep("1000", 1000),
                       rep("10000", 10000))) |>
  mutate(die_1 = map_dbl(N, ~ sample(c(1:6), size = 1))) |> 
  mutate(die_2 = map_dbl(N, ~ sample(c(1:6), size = 1))) |> 
  mutate(result = die_1 + die_2) |>
  mutate(N = as.factor(N)) |>
  mutate(N = fct_inseq(N)) |>
  summarise(N, result) |>
  ggplot(aes(x = result)) +
    geom_histogram(aes(y = stat(density)),
                   binwidth = 1, 
                   color = "white") +
    labs(title = "Empirical Probability Distribution",
           subtitle = "Sum from rolling two dice, Sample size changes",
           x = "Outcome\nSum of Two Die",
           y = "Probability") +
    facet_wrap(~ N, scales = "free") +
    scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) +
    scale_y_continuous(labels= scales::percent_format(accuracy = 1))

dice_p

#dice_p use to show the distribution

```

The more data you have, the more that the empirical distribution will match the data generating mechanism, if your assumptions about the DGM are correct.


### Exercise 1

Before we begin, write two sentences explaining what is a *Empirical Probability Distribution*.


```{r rolling-two-dice-1}
question_text(NULL,
	message = "Empirical Probability Distribution is a type of distribution that is completely based on data.",
	answer(NULL,
	correct = TRUE),
	allow_retry = FALSE,
	incorrect = NULL,
	rows = 6)
```

<!-- DK: Make answers good! -->


### Exercise 2

Use the `rep()` to repeat the value "10" three times.

```{r rolling-two-dice-2, exercise = TRUE}

```

```{r rolling-two-dice-2-hint-1, eval = FALSE}
rep(10 , 3)
```

###

There are others arguments within `rep()` that can be very useful, for example `length.out` sets a limit for the repetition to happen so that when rep reaches that limit it will automatically stop generating data. 

### Exercise 3

Create a `tibble()` which has one variable, `C`, with the value of `rep(10, 3)`.

```{r rolling-two-dice-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-3-hint-1, eval = FALSE}
tibble(C = rep(10, 3))
```

### Exercise 4

Modify your answer to the previous exercise by using `c()` so that `C` has a value which includes `rep(10, 3)` and `rep(500, 2)`.

```{r rolling-two-dice-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-4-hint-1, eval = FALSE}
tibble(C = c(rep(10, 3), rep(500, 2)))
```


### Exercise 5

Pipe down your result, use `mutate()` to add a new variable "dice" and have "dice" equal to an random values from 1 : 6 using `sample()`,  This should returns an error. 
```{r rolling-two-dice-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-5-hint-1, eval = FALSE}
... |>
  mutate(dice = sample(1:6))
```

### 

This should return an error saying dice `must be size 5 or 1, not 6`.


### Exercise 6

We only want one value from 1 to 6, so add in another argument `size` and set it equal to 1.
```{r rolling-two-dice-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-6-hint-1, eval = FALSE}
... |>
  mutate(dice = sample(1:6, size = 1))
```

### 

Notice the column dice will always return the same number, this is not what we want. In order to fix this we need to use the map_* function.


### Exercise 7

Use `map_dbl()` and set the first argument to C and formula to the `sample()` function we create in the last exercise. 
```{r rolling-two-dice-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-7-hint-1, eval = FALSE}
... |>
  mutate(dice = map_dbl(C, ~sample(1:6, size = 1)))
```

### 

Now let's apply the knowledge to the real game. 


### Exercise 8

<!-- DK: Split this into 3 or 4 separate questions. And then, ask this question. Firts, question has answer of rep(10, 3). Second question has answer of tibble(N = rep(10, 3)). Third question has answer of tibble(N = c(rep(10, 3), rep(500, 2))). Fourth question has answer  tibble(N = c(rep(10, 3), rep(500, 2))) |>  mutate(result = ...) -->

Create a `tibble()` with variable `N`, and set N to a list of values representing our sample size, then use `rep()` to repeat the function the same number of times as the sample size. We want 6 different sample size: 10, 20, 50, 100, 1000, 100000.

```{r rolling-two-dice-8, exercise = TRUE}

```

```{r rolling-two-dice-8-hint-1, eval = FALSE}
tibble(N = c(rep("...", ...), 
             rep("...", ...),
             rep("...", ...),
             rep("...", ...),
             rep("...", ...),
             rep("...", ...)))
```

```{r rolling-two-dice-8-hint-2, eval = FALSE}
tibble(N = c(rep("10", 10), 
             rep("20", 20),
             rep("...", ...),
             rep("...", ...),
             rep("...", ...),
             rep("...", ...)))
```

### Exercise 9

Recall exercise 7, let's create another dice, set it equal to one of the 6 values from (1,2,3,4,5,6) for each row of N using both map_dbl() and `sample()`. Lastly assign it to the name "die_1" using `mutate().`
```{r rolling-two-dice-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-9-hint-1, eval = FALSE}
... |>
 mutate(...= map_dbl(..., ~ ...))
```

```{r rolling-two-dice-9-hint-2, eval = FALSE}
... |>
 mutate(...= map_dbl(N, ~sample(c(...: ...), size = 1)))
```

### Exercise 10

Copy and paste the result from above, and do the exact same thing again but instead named to the value `die_2`, because we need the results for two dices.

```{r rolling-two-dice-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-10-hint-1, eval = FALSE}
... |>
  mutate(...= map_dbl(N, ~sample(c(...:...), size = 1)))
```

### Exercise 11

Copy and paste the results from above, use the `mutate()` function once again, name the value of the sum of `die_1` and `die_2` to "result"

```{r rolling-two-dice-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-11-hint-1, eval = FALSE}
... |>
  mutate(result = die_1 + die_2)
```

### Exercise 12

Copy and paste the above, then use `summarise()` to include the column "N" and "result" only

```{r rolling-two-dice-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-12-hint-1, eval = FALSE}
... |>
  summarise(N, ...)

```

### Exercise 13

Copy and paste the code above. Then use `ggplot()` to graph the Empirical Distribution, setting `x = result` within `aes()`, and then add a layer of `geom_histogram()`

```{r rolling-two-dice-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-13-hint-1, eval = FALSE}
... |>
  ggplot(aes(x = ...)) +
    geom_histogram()
```

### Exercise 14

Copy and paste your code from above, recalling the function `facet_wrap()`. Use the layer `facet_wrap()` to separate the graph into six smaller distributions. Don't forget the `~` within `facet_wrap()`.

```{r rolling-two-dice-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-14-hint-1, eval = FALSE}
...+
  facet_wrap(...)
```

```{r rolling-two-dice-14-hint-2, eval = FALSE}
... +
  facet_wrap(~ N)
```

Your graph should look similar to this.
```{r}
tibble(N = c(rep("10", 10), 
             rep("20", 20),
             rep("50", 50),
             rep("100", 100),
             rep("1000", 1000),
             rep("10000", 10000))) |>
  mutate(die_1 = map_dbl(N, ~ sample(c(1:6), size = 1))) |> 
  mutate(die_2 = map_dbl(N, ~ sample(c(1:6), size = 1))) |> 
  mutate(result = die_1 + die_2) |>
  ggplot(aes(x = result)) +
  geom_histogram() +
  facet_wrap(~ N)
```

### Exercise 15

Now we have a graph, but it's not looking very good. It seems like only the 10000 strip fills up bars the. This is because the 10000 scales is so big, that the bars are blocked. In order for them to show within `facet_wrap()`, add another argument `scales`, and set it equal to "free". 
```{r rolling-two-dice-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-15-hint-1, eval = FALSE}
...+
  facet_wrap( ~ ..., scales = "...")
```

This allows the graph to use it's own scale, instead an universal scales that covered all plots.

Your graph should looks like this
```{r}
set.seed(2)
tibble(N = c(rep("10", 10), 
             rep("20", 20),
             rep("50", 50),
             rep("100", 100),
             rep("1000", 1000),
             rep("10000", 10000))) |>
  mutate(die_1 = map_dbl(N, ~ sample(c(1:6), size = 1))) |> 
  mutate(die_2 = map_dbl(N, ~ sample(c(1:6), size = 1))) |> 
  mutate(result = die_1 + die_2) |>
  ggplot(aes(x = result)) +
  geom_histogram() +
  facet_wrap(~ N,scales = "free")
```

### Exercise 16

Copy and paste your results from above. Note that you see the red `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Let's get rid of this by adjusting binwidth for our plots, within `geom_histogram()` set "binwidth" equal to 1, and "color" between bins equal to "white".
```{r rolling-two-dice-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-16-hint-1, eval = FALSE}
...+
  geom_histogram(binwidth = ..., color = "...") +
  ...
```

```{r rolling-two-dice-16-hint-2, eval = FALSE}
... |>
  ggplot(aes(x = result)) +
  geom_histogram(binwidth = 1, color = "white") +
  facet_wrap(~ N,scales = "free")
```

### 

Notice the panal(gray bar) above each of the sixth distributions, they are out of order, we want to place them like this (10,20,50,100,1000,10000) so that we can see the evolution of the shape of the graph as the sample size increase.


### Exercise 17

Go back to your previous code, right after the `summarize()` and before your `ggplot()`, use `mutate()` and `as.factor()` to reformat N into factor.

```{r rolling-two-dice-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-17-hint-1, eval = FALSE}
... |>
  mutate(N = as.factor(N))
```

### Exercise 18

Pipe down your results, and do the exact same thing again for N, using `mutate()`, but this time we will use the new function `fct_inseq()` to replace `as.factor()`. This allows us to reorder the sequence from least to greatest.

```{r rolling-two-dice-18, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-18-hint-1, eval = FALSE}
... |>
  mutate(N = fct_inseq(N))
```

### Exercise 19

Copy and paste your code from above. Now look at the values on the y-axis, for each one of the six plots the value is different. This is because we have different sample sizes, and it makes sense for each to have different a different *count* in order to create an *Empirical Probability distribution*. In order to *normalized* the plot, within `geom_histogram()`, use `aes()`. Inside `aes()`, we use the argument `y = stat(density)` to set it to put percent on y-axis.

```{r rolling-two-dice-19, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-19-hint-1, eval = FALSE}
... +
    geom_histogram(aes(y = stat(...))) +
  ...
```

```{r include = FALSE}
set.seed(2)
tibble(N = c(rep("10", 10), 
             rep("20", 20),
             rep("50", 50),
             rep("100", 100),
             rep("1000", 1000),
             rep("10000", 10000))) |>
  mutate(die_1 = map_dbl(N, ~ sample(c(1:6), size = 1))) |> 
  mutate(die_2 = map_dbl(N, ~ sample(c(1:6), size = 1))) |> 
  mutate(result = die_1 + die_2) |>
  mutate(N = as.factor(N)) |>
  mutate(N = fct_inseq(N)) |>
  ggplot(aes(x = result)) +
  geom_histogram(aes(y = stat(density)),binwidth = 1, color = "white") +
  facet_wrap(~ N,scales = "free")
```

### Exercise 20

Now use `scale_x_continuous()` so the x-axis has `breaks` to the sequence between 2 and 12 common difference is 1 using `seq()`. Set the `labels` for the breaks as from 2 to 12.

```{r rolling-two-dice-20, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-20-hint-1, eval = FALSE}
... +
  scale_x_continuous(breaks = seq(...,..., ...), labels = ...:...) 
```

```{r rolling-two-dice-20-hint-2, eval = FALSE}
... +
  scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12)
```

### Exercise 21

Now use `scale_y_continuous()` to put the x-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1.

```{r rolling-two-dice-21, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-21-hint-1, eval = FALSE}
... +
  scale_y_continuous(labels = scales::percent_format(...))
```

### Exercise 22

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels.

```{r rolling-two-dice-22, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>


```{r rolling-two-dice-22-hint-1, eval = FALSE}
... +
  labs(title = "...",subtitle = "...")
```

Reminder: Your plot should look similar to the the one below. 

```{r}
dice_p
```

###

The larger the sample size, the more closely your empirical distribution will match the data generating mechanism (DGM) **if** your assumptions about the DGM are correct.

## Weighted dice
###

If your assumptions about the process which generates the data (i.e. the data generating mechanism) are false, then it may take a lot of data to see evidence for that falseness. 

###

Consider this plot:

```{r}
dicefalse_p <- tibble(m = c(rep("10", 10), 
                           rep("50", 50),
                           rep("10000", 10000))) |>
  mutate(die_1 = map_dbl(m, ~ sample(1:6, 
                                     size = 1, 
                                     prob = c(0.1, 0.1,  0.1, 
                                              0.1, 0.25, 0.35)))) |> 
   mutate(die_2 = map_dbl(m, ~ sample(1:6, 
                                      size = 1,
                                      prob = c(0.1, 0.1, 0.1, 
                                               0.1, 0.25, 0.35)))) |> 
   mutate(result = die_1 + die_2) |>
   mutate(m = as.factor(m)) |>
   mutate(m = fct_inseq(m)) |>
  
  # The above two steps use for scale_x_continuous breaks and labels to not exclude the values not have no values.
  
   summarise(m,result) |>
   ggplot(aes(x=result))+
   geom_histogram( aes(y = stat(density)),
                   binwidth = 1, 
                   color = "white") +
   labs(title = "Empirical Probability Distribution (Bad assumtions)",
         subtitle = "Sum from rolling two dice, sample size change",
         x = "Outcome\nSum of Two Die",
         y = "Probability") +
   facet_wrap(~ m, scales = "free")+
   scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) +
   scale_y_continuous(labels = scales::percent_format(accuracy = 1))

dicefalse_p
```


### Exercise 1

Start a pipe with`tibble()` with variable `m`, and set m to a list of value representing our sample size, then use `rep()` to repeat the function same numbers of times as the sample size. We want 3 different sample size: 10,50, 100000.

```{r rolling-two-dice-bad-assumption-ex-1, exercise = TRUE}

```

```{r rolling-two-dice-bad-assumption-ex-1-hint, eval = FALSE}
tibble(m = c(rep("10", 10), 
             rep("50", 50),
             rep("10000", 10000)))
```

###
Keep this `tibble()` as we will be using later.

### Exercise 2

Use `sample()` to generate integers 1 to 6 for any order.
```{r rolling-two-dice-bad-assumption-ex-2, exercise = TRUE}

```


```{r rolling-two-dice-bad-assumption-ex-2-hint, eval = FALSE}
sample(1:6)
```

###

Remember do use the `:` because it is very convenient for any consecutive integers.

### Exercise 3

Within `sample()`, add another argument `size` set it equal to 1 because we only want to select 1 value from the list of 6 numbers. Click `run` multiple time to see what happens.
```{r rolling-two-dice-bad-assumption-ex-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-bad-assumption-ex-3-hint, eval = FALSE}
sample(1:6, size = 1)
```

###
Now you have run this statement multiple time, you should realize that each number's probability to appear, should be quite similar, since you haven't seen a number which appears the most frequently.


### Exercise 4

Within the `sample()`, add another argument `prob`, let's add in the probability for the number to appear, which is in this case set the value of `prob` to equal to c(0.1,0.1,0.1,0.1,0.25,0.35)`. And run it multiple times.

```{r rolling-two-dice-bad-assumption-ex-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-bad-assumption-ex-4-hint, eval = FALSE}
sample(1:6, size = 1, prob = c(0.1,0.1,0.1,0.1,0.25,0.35))
```

###

This time the result should be easy to see, the 5s and 6s appears alot more frequent than other number, this is what the `prob` argument does, it allow us to manually assign the probability for number to appear during sampling. 

### Exercise 5

Copy paste the tibble from Exercise 1. Use `mutate()` to set variable `die_1` to the sample() we just created. This should create a tibble with the first column called `m`, and the second column called `die_1`, and all die_1 values are the same.

```{r rolling-two-dice-bad-assumption-ex-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-bad-assumption-ex-5-hint, eval = FALSE}
tibble(m = c(rep("...", ...), 
             rep("...", ...),
             rep("...", ...))) |>
  mutate(die_1 = sample(1:6, size = 1, prob = c(0.1,0.1,0.1,0.1,0.25,0.35)))
```

###

The reason why die_1 is all the same is because the mutate function only generates a single value from sample(), and then copies that for every row in the tibble.

### Exercise 6

Within the same `mutate()` we created set die_1 to the value of `map_dbl()`, and within `map_dbl()`, set the first argument to m, and formula to `sample()`, don't forget the `~` for `sample()`.
```{r rolling-two-dice-bad-assumption-ex-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-bad-assumption-ex-6-hint, eval = FALSE}
tibble(m = c(rep("10", 10), 
             rep("50", 50),
             rep("10000", 10000))) |>
  mutate(die_1 = map_dbl(m, ~ sample(1:6, size = 1, prob = c(0.1, 0.1, 0.1, 0.1, 0.25,0.35))))
```

###

Now the number on the column `die_1` should be different, now you can visualize how 6s and 5s appear most frequent due to the probabiility we set for them. 


### Exercise 7

Pipe down your result, now let's create another dice called `die_2`, do the exact same thing again as `die_1`, the only difference should be the variable name.

```{r rolling-two-dice-false-assumption-ex-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-7-hint, eval = FALSE}
... |>
  mutate(die_2 = map_dbl(m, ~ sample(1:6, size = 1, prob = c(0.1, 0.1, 0.1, 0.1, 0.25,0.35))))
```

### Exercise 8

Use the `mutate()` function once again,set "result" to the value of the sum of `die_1` and `die_2`.

```{r rolling-two-dice-false-assumption-ex-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-8-hint, eval = FALSE}
... |>
  mutate(result = ... + ... )
```

###

The following will be very similar to the first exercise.

### Exercise 9

Use `summarise()`, only include `m` and `result`.

```{r rolling-two-dice-false-assumption-ex-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-9-hint, eval = FALSE}
... |>
  summarise(m, result)
```

### Exercise 10

Keep piping down your result, use mutate() and as.factor to change m to a factor.

```{r rolling-two-dice-false-assumption-ex-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-10-hint, eval = FALSE}
... |>
  mutate(m = as.factor(m))
```


### Exercise 11

Use `mutate()` once again to set m from smallest to largest using `fct_inseq()`.

```{r rolling-two-dice-false-assumption-ex-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-11-hint, eval = FALSE}
... |>
  mutate(m = fct_inseq(m))
```

### Exercise 12

Let's start plotting by using `ggplot()` to graph the Empirical Distribution. Within `aes()`, set `x = result`, and then add a layer of `geom_histogram()`

```{r rolling-two-dice-false-assumption-ex-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-12-hint, eval = FALSE}
... |>
  ggplot(aes(...)) +
  geom_histogram()
  
```


### Exercise 13

Use `facet_wrap()` and set the argument to separate the graph into three small distributions. Don't forget the `~` within `facet_wrap()`.

```{r rolling-two-dice-false-assumption-ex-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-13-hint, eval = FALSE}
... +
  facet_wrap( ~ ...)
```

### Exercise 14

Note that you see the red `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Let's get rid of this by adjusting binwidth for our plots, within `geom_histogram()` set "binwidth" equal to 1, and "color" between bins equal to "white".
```{r rolling-two-dice-false-assumption-ex-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-14-hint, eval = FALSE}
... +
  geom_histogram(binwidth = ..., color = "...") 
```


### Exercise 15

Within `facet_wrap()`, add another argument `scales`, and set it equal to "free". 
```{r rolling-two-dice-false-assumption-ex-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-15-hint, eval = FALSE}
... +
  facet_wrap(~ ..., scales = "...")

```

###
This allows the graph to scale freely. 

### Exercise 16

Now look at the values on the y-axis, for each one of the sixth plot the value is different, this is because we have different sample size, and it makes sense for each to have different *count*.  In order to *normalized* the plot, Within `geom_histogram()`, use `aes()` . Inside `aes()`, we use the argument `y = stat(density)` to set it to put percent on y-axis.

```{r rolling-two-dice-false-assumption-ex-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-16-hint, eval = FALSE}
... +
  geom_histogram(aes(y = stat(...))) +
  ...
```


### Exercise 17

Now use `scale_x_continuous()` so the x-axis has `breaks` to the sequence between 2 and 12 with a common difference of 1 using `seq()`. Set the `labels` for the breaks as from 2 to 12.
```{r rolling-two-dice-false-assumption-ex-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-17-hint, eval = FALSE}
... +
  scale_x_continuous(breaks = seq(...,..., ...), labels = ...:...) 
```

### Exercise 18

Now use `scale_y_continuous()` to put the x-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1.
```{r rolling-two-dice-false-assumption-ex-18, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rolling-two-dice-false-assumption-ex-18-hint, eval = FALSE}
... +
  scale_y_continuous(labels = scales::percent_format(...))
```

### Exercise 19

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels.

```{r rolling-two-dice-false-assumption-ex-19, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>


```{r rolling-two-dice-false-assumption-ex-19-hint, eval = FALSE}
... +
  labs(title = "...",subtitle = "...")
```

Reminder: Your plot should look similar to the the one below. 

```{r}
dicefalse_p
```

###

Remember that in this section you've learned that it may take very large amounts of data to be assured that your initial assumptions to generate that data are false.

## Different data generating mechanisms
###

There are an infinite number of possible data generating mechanisms (DGMs) for every data science problem. 

###

Consider this graph where we have different probabilities for a 6 to appear, where 0 represents a zero percent chance, 0.2 is 20%, 0.4 is 40%, 0.6 is 60%, 0.8 is 80% and 1 is 100% respectively. Every single one of them represent an different Data Generating Mechanism (DGM). Now let's make the plot shown below.

```{r}
# DK: Comments!

dgm_p <- tibble(die1 = list(c(0.2, 0.2, 0.2, 0.2, 0.2, 0), 
                   c(0.16, 0.16, 0.16, 0.16 ,0.16, 0.20), 
                   c(0.12, 0.12, 0.12, 0.12, 0.12, 0.40), 
                   c(0.08, 0.08, 0.08, 0.08, 0.08, 0.60),
                   c(0.04, 0.04, 0.04, 0.04, 0.04, 0.80), 
                   c(0, 0, 0, 0, 0, 1))) |>
   mutate(die2 = die1) |>
   mutate(prob = c(.0, .2, .4, .6, .8, 1) ) |>
  
  # Use only for facet_wrap
   mutate(sample1 = map(die1, ~ sample(1:6, replace = TRUE, 
                                       size = 10000, prob = .))) |>
   mutate(sample2 = map(die2, ~ sample(1:6, replace = TRUE, 
                                       size = 10000, prob = .))) |>
   unnest(c(sample1, sample2)) |>
   mutate(sum = sample1 + sample2) |>
   mutate(sum = factor(sum, 2:12)) |>
   group_by(prob, sum) |>
   summarise(count = n(), .groups = 'drop') |>
   mutate(perc = count/10000) |>
   ggplot(aes(x = sum ,y = perc)) + 
    geom_bar(stat = "identity")+
  
  # Should be include this some place in previous exercises cause we rarely see this "identity".
  
    facet_wrap(~ prob, scales = "free")+
  
  # scales = "free" in order of the list. 
  
    scale_x_discrete(drop = FALSE) +
    scale_y_continuous(labels = scales::percent_format(accuracy = 1)) +
   labs(title = "Empirical Probability Distribution (6 DGM)",
         subtitle = "Sum from rolling two dice, assumptions changes",
         x = "Outcome\nSum of Two Die",
         y = "Probability")

dgm_p 
```

### Exercise 1

Recall `list()`, within `list()` have 6 values, 0.2, 0.2, 0.2, 0.2, 0.2, and 0, where each number represent the probability of dice in our first DGM.
```{r different-data-gener-1, exercise = TRUE}

```


```{r different-data-gener-1-hint, eval = FALSE}
list(0.2, 0.2, ..., ..., ..., ...)
```


### Exercise 2

Now use `c()` around the 6 values, this should returns the 6 values in a row.
```{r different-data-gener-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-2-hint, eval = FALSE}
list(c(0.2, 0.2, ..., ..., ..., ...))
```


### Exercise 3

Add another 6 values within `list()` - 0.16, 0.16, 0.16, 0.16 ,0.16, 0.20 using use c(), remember to add `,` to seperate the two rows.The 6 value we use hear represent the probability assumptions of the dice for our second DGM.

```{r different-data-gener-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-3-hint, eval = FALSE}
list(c(0.2, 0.2, ..., ..., ..., ...), 
     c(..., ..., ..., ..., ..., ...))
```

### Exercise 4

Do the same thing for the third through sixth DGM's. 3rd DGM probability is `(0.12, 0.12, 0.12, 0.12, 0.12, 0.40)`, fourth is `(0.08, 0.08, 0.08, 0.08, 0.08, 0.60)`, fifth is `(0.04, 0.04, 0.04, 0.04, 0.04, 0.80)`, and the sixth is `(0, 0, 0, 0, 0, 1)`.
```{r different-data-gener-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-4-hint, eval = FALSE}
list(c(0.2, 0.2, 0.2, 0.2, 0.2, 0), 
     c(0.16, 0.16, 0.16, 0.16 ,0.16, 0.20), 
     c(0.12, 0.12, 0.12, 0.12, 0.12, 0.40), 
     c(0.08, 0.08, 0.08, 0.08, 0.08, 0.60),
     c(0.04, 0.04, 0.04, 0.04, 0.04, 0.80), 
     c(0, 0, 0, 0, 0, 1))
```


### Exercise 5

Start a new pipe with `tibble()` and set a column name to `die1`. Assign `die1` to the list we just created (copy paste from the previous exercise). Note the difference between a list and a tibble (list-column). This tibble should includes a list of 6 columns with each being `<dbl [6]>`, means that it consist of 6 values whose vector is a `double`.

```{r different-data-gener-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-5-hint, eval = FALSE}
tibble(die1 = list(c(0.2, 0.2, 0.2, 0.2, 0.2, 0), 
                   c(0.16, 0.16, 0.16, 0.16 ,0.16, 0.20), 
                   c(0.12, 0.12, 0.12, 0.12, 0.12, 0.40), 
                   c(0.08, 0.08, 0.08, 0.08, 0.08, 0.60),
                   c(0.04, 0.04, 0.04, 0.04, 0.04, 0.80), 
                   c(0, 0, 0, 0, 0, 1)))
```


### Exercise 6

Use `mutate()`, create a new column name is `die2`, and set `die2` equal to `die1` as they have the same probability for each DGM.
```{r different-data-gener-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-6-hint, eval = FALSE}
... |>
  mutate(die2 = die1)
```

### Exercise 7

Use `mutate()` again with a new column name `prob`, and set it equal to `.0, .2, .4, .6, .8, 1` using `c()`
```{r different-data-gener-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-7-hint, eval = FALSE}
... |>
  mutate(prob = c(.0, .2, .4, .6, .8, 1)) |>
```

###
We are setting the `prob` column not for the actual probability when calculating but instead for later use of `facet_wrap()` to split up the graph.

### Exercise 8

Use mutate() to create a new variable called `sample1` which is set equal to `map()`. Inside `map()` set the first argument to die1, the second argument is the formula `sample()` which has 4 arguments, the first being consecutive values from 1 to 6, secondly set `replace` equal to `TRUE`, thirdly set `size` equal to `10000`, and finally set `prob` equal to `.`.
```{r different-data-gener-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-8-hint, eval = FALSE}
... |>
    mutate(sample1 = map(die1, ~ sample(1:6, replace = TRUE, 
                                       size = 10000, prob = .)))
```

###
The `.` in the `sample()` function is key, as it carries the list-column we create in the tibble, and applies it to the actual dice rolling process.

### Exercise 9

Use mutate() create a new variable called `sample2` which is set equal to `map()`. Inside `map()` set the first argument to die1, second argument is the formula `sample()` which has 4 arguments, the first being consecutive value from 1 to 6, second set `replace` equals `TRUE`, third set `size` equal to 10000, and fourth set `prob` equals `.`.
```{r different-data-gener-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-9-hint, eval = FALSE}
... |>
   mutate(sample2 = map(..., ~ sample(..., replace = TRUE, 
                                       size = ..., prob = .)))
```

###
Now we created the two dice, each roll 10000 times for each individual world of probabilities (DGM).

### Exercise 10

Now use `unnest()`, around `c()` which includes the two variables `sample1` and `sample2`.
```{r different-data-gener-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-10-hint, eval = FALSE}
... |>
  unnest(c(..., ...))
```

###
This is a key step because without it, R would return an error when we find the sum of the two dice as non-numeric arguments, so we need `unnest()` to bring them back into regular columns.


### Exercise 11

Use `mutate()` create a new variable called `sum`, and set it equal to the sum of `sample1` and `sample2`.
```{r different-data-gener-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-11-hint, eval = FALSE}
... |>
  mutate(sum = sample1 + sample2)
```

###
There are many arguments in `mutate()` we haven't tried, for example `.keep` which allows you to control which columns from the data are retained in the output.

### Exercise 12

Use `mutate()` again to set `sum` equal to `factor()` which has two arguments, the first being `sum`, and second being `2:12`.
```{r different-data-gener-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-12-hint, eval = FALSE}
... |>
   mutate(sum = factor(sum, 2:12))
```

###
The reason we've included this step is for later when we graph the 6 faceted distributions, since some like the sixth one will only shows a giant bar, the `factor()` here is giving `sum` levels, and setting all 11 possible values from 2 to 12 to appear in each distribution. Further steps need to be taken later to have fully accomplish this.
`
### Exercise 13

Use `group_by()` which has two arguments, `prob` and `sum`.
```{r different-data-gener-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-13-hint, eval = FALSE}
... |>
  group_by(..., ...)
```

###
The order of the two matter, as it determines the next step of `summarise()`, if we switch the two arguments the graph will looks completely different.

### Exercise 14

Now use `summarise()` create a new variable called, `count`, and set it equal to `n()`, then add a new argument `.groups` and set it equal to `"drop"`.
```{r different-data-gener-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-14-hint, eval = FALSE}
... |>
   summarise(count = n(), .groups = 'drop')
```

###
If we run the `summarise()` without `group_by()`, r will only returns 1 rows, yet with `group_by()`, r will include the rows and condense it by operation, this time is `n()` means count. 

### Exercise 15

Use `mutate()` and create the variable `perc`, and set it equal to `count` divided by 10000.
```{r different-data-gener-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-15-hint, eval = FALSE}
... |>
   mutate(perc = count/10000)
```

###
This steps helps us consolidate the percentage for each bar in the distribution.

### Exercise 16

Using `ggplot()`, with `aes()`, which should have two arguments. In the first we set`x` equal to `sum`, then we set `y` to `perc`. Add the layer of `geom_bar()`.
```{r different-data-gener-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-16-hint, eval = FALSE}
...|>
 ggplot(aes(x = ... ,y = ...))+
  geom_bar()
```

###
We use `geom_bar()` here is because `geom_histogram()` won't work because it has two aesthetic, `geom_col()` because later we need to add `stat` which is an unknown paramter in `geom_col()`.


<!-- Six possible states of the world. Or five possible models. Or five possible assumptions. p_6 = c(0, 0.20, 0.4, 0.6, 0.8, 1). Do 10,000 draws for each. The DGM is something which is made --- in theory --- before you even look at your data. So, let's make 5 of them. Of course, there are an infinite number of possible DGMs. -->

### Exercise 17

Within `geom_bar()` set `stat` equal to "identity".
```{r different-data-gener-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-17-hint, eval = FALSE}
...+
 geom_bar(stat = "...")
```

###
This allows us to do the counting and stacking up of the bars with the two aesthetics in `ggplot()`.Since we already calculated the percentage before plotting we no longer need the `after_stat()` argument to help us count the number in each bars.

### Exercise 18

Use `facet_wrap()`, which have the first argument being `~ prob`, second which we set `scales` equal to `free`.
```{r different-data-gener-18, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-18-hint, eval = FALSE}
...+
 facet_wrap(~ prob, scales = "free")
```

###
`scales = "free"` allows the distribution to follow the order in the tibble, instead going from numeric order.

### Exercise 19

Use `scale_x_discrete()`, and set `drop` equal to `FALSE`.
```{r different-data-gener-19, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-19-hint, eval = FALSE}
... +
  scale_x_discrete(drop = FALSE)

```

###
We are using `scale_x_discrete()` instead `scale_x_continuous()` because for the `factor` step in exercise 12, factors only work for discrete value, and argument `drop` equals `FALSE` is telling r to not drop the columns that have no values in them.

### Exercise 20

Use `scale_y_continuous()` to put the x-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1.
```{r different-data-gener-20, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-20-hint, eval = FALSE}
... +
  scale_y_continuous(labels = scales::percent_format(...))
```


### Exercise 21

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels.

```{r different-data-gener-21, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r different-data-gener-21-hint, eval = FALSE}
... +
  labs(title = "...",subtitle = "...")
```


Reminder: Your plot should look similar to the the one below. 

```{r}
dgm_p
```



## Rejecting a proposed DGM
###

If there is a discrepancy when comparing the DGM models to the real data, this determines whether the DGM models need to change or reject.

<!-- Someone says: 5s and 6s have a 20% chance, all other numbers have a 15% chance. We simulate that DGM. And we compare --- side by side histograms? overlapping histograms? overlapping densities? maybe use patchwork --- 10,000 data points (generated by dice with 20% chance for *4* and 5 and 6) --- although we are considering this to be real data which someone handed us) with 10,000 points from their DGM. -->

<!-- Maybe data is stacked --- meaning "tidy" --- with a column called "source" with values either "data" or "DGM".  -->

<!--  Shows what happens when we directly compare data  to simulations from the model (which we define as the truth.) With 10,000 draws, it is obvious that the data demonstrates that the model is false. Key is that we are comparing the model with the data and, on the basis of a discrepancy between the two, determining that we need to fix the model. Introduce the concept of model checking. -->

###

Consider the following graph where we simulate a DGM in which we claim that in a fair dice roll that 5s and 6s have a 20% chance, all other numbers have a 15% chance. And then we have the truth where we defined that the dice have 20% chance for *4* and 5 and 6. Then roll the dices 10,000 times for each scenario and calculate the sum of the dices. We can see an clear discrepancy between the DGM and the *Truth*.

```{r}
rej_p <- tibble(die1 = list(c(0.15, 0.15, 0.15, 0.15, 0.20, 0.20), 
                   c(0.13, 0.13, 0.13, 0.20 ,0.20, 0.20))) |>
  
  # 1 : probability dice of the DGM, 2: probability of dice of "truth".
         mutate(die2 = die1 ) |>
         mutate(prob = c("DGM", "Truth")) |>
         mutate(sample1 = map(die1, ~ sample(1:6, replace = TRUE, size = 10000, prob = .))) |>
         mutate(sample2 = map(die1, ~ sample(1:6, replace = TRUE, size = 10000, prob = .))) |>
         unnest(c(sample1, sample2)) |>
         mutate(sum = sample1 + sample2) |>
         ggplot(aes(sum)) + 
         geom_histogram(position = "identity", 
                        aes(y = stat(density),  
                            fill = prob),
                        binwidth = 1, 
                        color = "black", alpha = 0.5) +
         scale_x_continuous(breaks = seq(2, 12, 1), labels = 2:12) +
         scale_y_continuous(labels= scales::percent_format(accuracy = 1))+
      labs(title = "Empirical Probability Distribution (Rejecting DGM)",
         subtitle = "Sum from rolling two dice, determine the dicrepency between the two distributions",
         x = "Outcome\nSum of Two Die",
         y = "Probability")

rej_p
```

### Exercise 1

Use `list()`, within `list()` have 6 values, 0.15, 0.15, 0.15, 0.15, 0.20, and 0.20 where each number represent the probability of dice in our DGM.
```{r rejecting-a-proposed-1, exercise = TRUE}

```


```{r rejecting-a-proposed-1-hint, eval = FALSE}
list(..., ..., ..., ..., ..., ...)
```


### Exercise 2

Now use `c()` around the 6 values, this should returns the 6 values in a row.
```{r rejecting-a-proposed-2, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-2-hint, eval = FALSE}
list(c(0.15, 0.15, ..., ..., ..., ...))
```


### Exercise 3

Add another 6 values within `list()` `-0.13, 0.13, 0.13, 0.20 ,0.20, 0.20` using use c(). The 6 value we use here represent the "truth" model.

```{r rejecting-a-proposed-3, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-3-hint, eval = FALSE}
list(c(0.15, 0.15, 0.15, 0.15, 0.20, 0.20), 
     c(0.13, 0.13, 0.13, 0.20 ,0.20, 0.20))
```

###
Our `truth` model isn't necessarily the `fair` model but it is the model that we assume is taken from the real world and is the reference that this DGM is trying to copy.

### Exercise 4

Start a pipe with `tibble()` set the column name to `die1`, and assign `die1` to the list we just created. Note the difference between a list and a tibble (list-column). This tibble should includes a list of 6 columns with each being `<dbl [6]>`, means that it consist of 6 values which vector is `double`.

```{r rejecting-a-proposed-4, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-4-hint, eval = FALSE}
tibble(die1 = list(c(...)))
```


### Exercise 5

Use `mutate()`, create a new column name is `die2`, and set `die2` equal to `die1` as they have the same probability for each DGM.
```{r rejecting-a-proposed-5, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-5-hint, eval = FALSE}
... |>
  mutate(die2 = ...)
```

### Exercise 6

Use `mutate()` create a new variable `prob`, and set it equal to `c()` which include "DGM" and "Truth".
```{r rejecting-a-proposed-6, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-6-hint, eval = FALSE}
... |>
  mutate(prob = c("DGM", "Truth"))
```

### Exercise 7

Use mutate() create a new variable called `sample1` which equal to `map()`, inside `map()` set the first argument to `die1`, second argument is the formula `sample()` which has 4 arguments, the first being consecutive value from 1 to 6, second set `replace` equals `TRUE`, third set `size` equal to `10000`, and fourth set `prob` equals `.`.
```{r rejecting-a-proposed-7, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-7-hint, eval = FALSE}
... |>
mutate(sample1 = map(die1, ~ sample(..., replace = TRUE, size = ..., prob = .))) 
```

###
Once again the `.` means that `prob` takes the same value as the data source `die1`, which we includes the probability for the dice there.

### Exercise 8

Use mutate() create a new variable called `sample2` which equal to `map()`, inside `map()` set the first argument to die1, second argument is the formula `sample()` which has 4 arguments, the first being consecutive value from 1 to 6, second set `replace` equals `TRUE`, third set `size` equal to 10000, and fourth set `prob` equals `.`.
```{r rejecting-a-proposed-8, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-8-hint, eval = FALSE}
mutate(sample2 = map(die1, ~ sample(..., replace = TRUE, size = ..., prob = .)))
```

###
`sample1` and `sample2` are the actual simulation processes, while `die1` just includes the probabilities for these two steps.

### Exercise 9

Now use `unnest()`, around `c()` which include two variables `sample1` and `sample2`.

```{r rejecting-a-proposed-9, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-9-hint, eval = FALSE}
... |>
  unnest(c(... , ...))
```


### Exercise 10

Use `mutate()` to create a new variable called `sum`, and set it equal to the sum of `sample1` and `sample2`.
```{r rejecting-a-proposed-10, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-10-hint, eval = FALSE}
... |>
  mutate(sum - ... + ...)
```


### Exercise 11

 Use `ggplot()`, within use `aes()`, which set`x` equal to `sum`, then add the layer of `geom_histogram()`.
```{r rejecting-a-proposed-11, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-11-hint, eval = FALSE}
...|>
  ggplot(aes(x=...))+
  geom_histogram()
```


### Exercise 12

Within `geom_histogram()` include `aes()`, which set `y` equals `stat(density)`.
```{r rejecting-a-proposed-12, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-12-hint, eval = FALSE}
... +
  geom_histogram(aes(y = stat(...)))
```

###
This step allows us to include both distributions in one graph.

### Exercise 13

Within `geom_histogram()` include another argument `position` and set it also equals to "identity".
```{r rejecting-a-proposed-13, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-13-hint, eval = FALSE}
... +
   geom_histogram(aes(...), position = "...")
```


### Exercise 14

Within `geom_histogram()` add 4 more small arguments, set `fill` equals `prob` within aes. Outside aes set `binwidth` equal to 1, set `color` equals `"black"` and set `alpha` equals `0.5`.
```{r rejecting-a-proposed-14, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-14-hint, eval = FALSE}
... +
   geom_histogram(aes(y = stat(...), position = "...",  fill = ...),
                  binwidth = ..., 
                  color = "...", alpha = ...) 
```


### Exercise 15

Now use `scale_x_continuous()` so the x-axis has `breaks` to the sequence between 2 and 12 with the common difference 1 using `seq()`. Set the `labels` for the breaks from 2 to 12.
```{r rejecting-a-proposed-15, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-15-hint, eval = FALSE}
... +
  scale_x_continuous(breaks = seq(...,..., ...), labels = ...:...) 
```

### Exercise 16

Now use `scale_y_continuous()` to put the x-axis in percent format. Within `scale_y_continuous()`, set `labels` to `scales::percent_format()`. Within `percent_format()` set `accuracy` to 1.
```{r rejecting-a-proposed-16, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-16-hint, eval = FALSE}
... +
  scale_y_continuous(labels = scales::percent_format(...))
```

### Exercise 17

Finally, use `labs()` to add the appropriate title, subtitle, and axis labels.
```{r rejecting-a-proposed-17, exercise = TRUE}

```

<button onclick = "transfer_code(this)">Copy previous code</button>

```{r rejecting-a-proposed-17-hint, eval = FALSE}
... +
  labs(title = "...",subtitle = "...")
```


Reminder: Your plot should look similar to the the one below. 

```{r}
rej_p
```




## Summary

The larger the sample size, the more closely your empirical distribution will match the data generating mechanism (DGM) **if** your assumptions about the DGM are correct.

If your assumptions about the processes which generate the data (i.e., the data generating mechanism) are false, then it may take lots of data to find evidence for that falseness. 

There are an infinite number of possible data generating mechanisms (DGMs) for every data science problem. 

If there is a discrepancy when comparing the DGM models to the real data, the DGM models need to change or be rejected.



```{r download-answers, child = system.file("child_documents/download_answers.Rmd", package = "tutorial.helpers")}
```
